### **배경**
<hr>

- 메모리는 각각의 주소가 할당된 일련의 바이트 코드로 구성되어 있습니다. 즉 바이트 코드의 나열입니다.
- CPU는 program counter(PC)가 지시하는 대로 메모리로부터 다음에 수행해야하는 명령어를 가져오는데, 해당 명령어는 필요한 경우 추가적인 데이터를 가져오거나
 반대로 데이터를 메모리로 내보낼 수 있습니다.


#### **기본 하드웨어**

- 메인 메모리와 각 코어 레지스터는 CPU가 직접 접근할 수 있는 유일한 범용 저장장치입니다. 기계 명령어들은 메모리 주소만을 취급하고, 디스크의 주소는 취급하지 않기
때문에 실행되는 모든 명령어와 데이터들은 CPU가 직접 접근할 수 있는 메모리나 레지스터에 있어야합니다. 만약 데이터나 메모리나 레지스터에 없다면 CPU가 
그것을 처리하기 전에 적재해야 합니다.
- 각각의 프로세스는 독립된 메모리 공간을 가질 수 있도록 보장해야하는데 이러한 독립적인 메모리 공간은 프로세스별로 보호하고, 병행 실행을 위해 여러 프로세스가
메모리에 적재되는것이 필수입니다.
- 프로세스마다 개별적인 메모리 공간을 가지기 위해서는 특정 프로세스만 접근할 수 있는 합법적인 메모리 주소 공간을 설정하고, 해당 프로세스만 접근하도록 해야합니다.
- 메모리 공간의 보호는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소를 비교함으로써 이루어지는데, 사용자 모드에서 수행되는 프로그램이 운영체제의 메모리 공간이나 다른 
사용자 프로그램의 메모리 공간에 접근하면 운영체제는 오류로 간주하고 트랩을 발생시킵니다.

##### **기준 레지스터**

- 가장 작은 합법적인 물리 메모리 주소의 값을 저장하고 있습니다.

##### **상한 레지스터**

- 주어진 영역의 크기를 저장하고 있습니다.

![스크린샷 2023-04-12 오후 8 59 29](https://user-images.githubusercontent.com/107396231/231450393-be903cd0-d5d5-495b-be29-8a5466e4ba3a.png)

#### **주소의 할당**

- 프로그램은 이진 실행파일로 디스크에 저장되어 있는데, 이 프로그램을 실행시키기 위해서는 메모리에 적재해야 합니다.
- 주소를 할당하기 위해서는 링커와 로더에 대해 살펴볼 필요가 있습니다.

##### **링커(Linker)**

- 링커는 여러가지를 연결하는것이다 라고 생각하면 이해하기 쉬울거 같습니다.
- 예를들어 프로그래머가 작성한 소스 코드를 컴퓨터가 이해할 수 있는 언어로 변환하는 작업을 컴파일링이라고 합니다. 그리고 컴파일된 것을 실행가능한 파일로 변환하는것을 링킹이라 합니다.
- 링커는 프로그램에서 사용된 모든 함수나 변수가 해당 정의에 맞는지 확인되도록 서로 다른 개체 파일과 라이브러리 간의 참조를 확인합니다.

##### **로더**

- 로더는 이진 실행파일을 메모리에 적재하는데 사용됩니다. 링커가 어떠한 프로그램을 실행시키기 위해 연결을 했다면 연결된 것을 실행하기 위해 메모리에 적재하는 역할을 수행하는게 로더라 할 수 있습니다.

#### **주소를 할당하는 3가지 방법**

##### **Compile Time Binding**

- 프로세스의 물리적 주소가 컴파일 시점에 정해집니다.
- 프로세스가 자신이 어느 위치에 들어가야할지 미리 알고 있다면 컴파일러는 절대 주소를 생성할 수 있습니다.
- 만약 실행도중 위치가 변경되어야 한다면 재컴파일 해야합니다.

##### **Load Time Binding**

- 프로세스가 자신이 메모리의 어느 위치에 들어가야할지 컴파일시점에 알지 못한다면 재배치 가능 코드를 생성해야 합니다. 이러한 재배치 가능 코드는
메모리의 어느 위치에서나 수행될 수 있는 기계어 코드인데 로더가 프로세스를 메모리에 적재하는 시점에 물리 주소를 결정하게 됩니다. 
그렇기 때문에 논리 주소와 물리 주소는 다르게 됩니다.

##### **Execution Time Binding**

- 프로세스가 수행이 시작된 이후에 프로세스가 실행될 때 메모리 주소를 변경하는 방법입니다.
- 실행시점에 물리 주소가 결정되며, 실행도중에도 물리 주소가 변경될 수 있습니다.
- 실행시간 주소 할당은 CPU가 주소를 참조할 때마다 address mapping table을 이용하여 바인딩을 점검합니다. 이러한 방식은 MMU라는 하드웨어 장치를 사용하여 논리적 주소를 물리적 주소로 변환하게 됩니다.

##### **Execution Time Binding는 어떻게 주소를 매핑시킬까?**

- 실행시간 주소 할당은 프로그램 실행중에 논리 주소를 물리 주소로 변환시켜줘야 하는데 이 작업은 하드웨어 장치인 MMU에 의해 실행됩니다.
- MMU를 사용한 기법에서는 기준 레지스터를 재배치 레지스터라 부르고, 이 재배치 레지스터를 사용하여 논리 주소가 물리 주소로 보내질 때 해당 논리 주소에 
임의의 값이 더해지게 됩니다. 그렇기 때문에 사용자 프로그렘은 결코 실제적인 물리주소에 접근할 수 없게 됩니다.
- 사용자 프로그램은 논리 주소를 사용한 것이고, 메모리 하드웨어는 논리 주소를 물리 주소로 바꾼것입니다.

![스크린샷 2023-04-12 오후 9 13 23](https://user-images.githubusercontent.com/107396231/231453574-363290f9-4241-445c-84cd-2d8ed3cf79c3.png)

<br>

### **연속 메모리 할당**
<hr>

- 메모리는 일반적으로 두 개의 부분으로 나누어지는데, 하나는 운영체제를 위한것이고 다른 하나는 사용자 프로세스를 위한 것입니다.
- 연속 메모리 할당은 이름에서 알 수 있듯이 각 프로세스들이 연속적인 메모리 공간을 차지하는 것입니다.

#### **메모리 보호**

- 연속 메모리 할당은 각 프로세스들이 연속적으로 메모리 공간을 차지하고 있기 때문에 각 프로세스별 메모리를 어떻게 보호할 수 있는가에대해 문제가 발생할 수 있습니다.
이러한 문제를 해결하기 위해서는 상한 레지스터와 재배치 레지스터를 사용하여 문제를 해결할 수 있습니다.
- CPU 스케줄러가 다음으로 수행할 프로세스를 선택할 때 디스패처는 context-switch할 때 재배치 레지스터와 상한 레지스터에 정확한 값을 적재합니다.
CPU에 의해 생성되는 모든 논리 주소는 이 레지스터들의 값을 참조해서 확인 작업을 거치기 때문에 운영체제와 다른 사용자 프로그램을 현재 수행중인 프로그램의 접근으로부터 보호할수 있습니다.

![스크린샷 2023-04-12 오후 9 19 47](https://user-images.githubusercontent.com/107396231/231455040-6b88f31b-5a37-4904-ac1f-67ee54729b8d.png)

#### **메모리 할당**

- 연속적인 메모리를 할당하기 위해서는 고정된 크기로 나누는 고정 분할과 프로세스의 크기를 고려해 나누는 가변 분할 방식이 있습니다.

##### **고정 분할**

- 분할의 크기가 모두 동일하거나, 서로 다를 수 있습니다. 분할 당 하나의 프로세스가 적재되기 때문에 동시에 메모리에 적재되는 프로세스의 수가 고정됩니다. 또한 수행가능한 프로세스의 최대 크기가 제한됩니다.

##### **가변 분할**

- 프로세스를 메모리의 가변 크기 파티션에 할당하는 것입니다.
- 각 파티션에는 하나의 프로세스만 할당할 수 있습니다.
- 가변 파티션 기법에는 운영체제가 사용 가능한 메모리 부분과 사용중인 메모리 부분을 나타내는 테이블을 사용하게 됩니다. 처음에는 모든 메모리가 사용자 프로세스에 사용 가능하며, 하나의 큰 사용 가능한 메모리 블록인 hole로 간주합니다.

##### **동적 메모리 할당 문제를 해결할 수 있는 기법**

- 최조 적합: 첫번째 사용 가능한 공간을 할당합니다.
- 최적 적합: 사용 가능한 공간 중 가장 작은 것을 할당합니다.
- 최악 적합: 가장 큰 사용 가능한 공간을 할당합니다.

#### **단편화**

- 단편화에는 외부 단편화와 내부 단편화가 있습니다.

##### **외부 단편화**

- 외부 단편화는 유휴 공간들을 모두 합치면 충분한 공간이 되지만, 그것들이 너무 작은 조각으로 여기저기 산재되어 있어 발생합니다.
- 즉 메모리가 너무 많은 작은 수의 매우 작은 조각들로 산재되어 있는것입니다.
- 외부 단편화의 심각한 문제는 모든 프로세스 사이마다 못 쓰게되는 가용 공간을 가질 수 있는데, 이 모든 공간들을 합쳐 하나의 큰 가용 공간으로 만들면 여기에 프로세스를 할당할 수 있습니다. 하지만 이 작업은 비용이 많이 소요됩니다.
- 외부 단편화를 해결할 수 있는 방법은 압축입니다. 압축은 메모리의 모든 내용을 한쪽으로 몰고 모든 가용 공간을 다른 한쪽으로 몰아서 하나의 큰 블록을 만드는 것입니다. 하지만 이 방법은 재배치가 어셈블 또는 컴파일 주소 할당 방법에는 사용할 수 없습니다. 그 이유는 압축이라는 것은 프로세스들의 재배치가 실행시점에 동적으로 이루어지는 경우에만 가능하기 때문입니다.

![스크린샷 2023-04-12 오후 10 02 07](https://user-images.githubusercontent.com/80187200/231465657-e23555bf-4d0e-43da-876f-4148791dcac9.png)

##### **내부 단편화**

- 내부 단편화는 프로세스가 할당된 공간보다 주어진 공간이 약간 더 클 수 있는데, 이러한 주어진 공간에 남는 공간이 내부 단편화입니다.
- 내부 단편화가 발생하는 이유는 프로세스가 메모리를 요청하면 할당을 분할된 크기의 정배수로만 해주므로 내부 단편화가 발생하게 됩니다.

![스크린샷 2023-04-12 오후 10 03 35](https://user-images.githubusercontent.com/80187200/231466042-fcf57bd6-35bf-4b7c-8127-b4923126ec67.png)

### **페이징**
<hr>

- 연속 메모리 할당은 여러가지 문제를 발생시킬 수 있습니다.(외부 단편화, 압축) 하지만 페이징은 외부 단편화와 압축의 문제를 해결할 수 있습니다.

#### **기본 방법**

- 물리 메모리는 프레임이라 불리는 고정된 크기의 블록으로 나뉘게 됩니다.
- 논리 메모리는 페이지라 불리는 고정된 크기의 블록으로 나뉘게 됩니다.
- CPU로부터 나오는 논리 주소는 페이지 번호(p)와 페이지 오프셋(d)의 두 부분으로 구성됩니다.
- 페이지 번호(p)는 페이지 테이블에 접근하기 위해 사용됩니다.
- 페이지 테이블은 물리 메모리의 프레임에 접근하기 위한 시작 주소를 가지고 있으며, 오프셋은 프레임에서의 시작 주소를 가지고 있습니다. 따라서 페이지 번호와 페이지 오프셋을 활용하여 물리 메모리 주소에 접근할 수 있습니다.

<img width="1041" alt="스크린샷 2023-04-13 오후 8 11 23" src="https://user-images.githubusercontent.com/80187200/231741294-83ea8b06-d92e-4aa6-b761-8e4b04d62ed5.png">

#### **과정**

1. 논리 주소에서 페이지 번호(p)를 추출하여 페이지 테이블의 인덱스로 사용합니다.
2. 페이지 테이블에서 해당 프레임 번호(f)를 추출합니다.
3. 페이지 번호 p를 프레임 번호 f로 변환합니다.
4. 프레임 번호 f를 사용하여 물리 메모리 주소에 존재하는 프레임 f에 접근합니다.
5. 페이지 오프셋을 사용하여 프레임 안에서의 인덱스로 사용합니다.

#### **장점**

- 메모리 공간을 연속적으로 사용하지 않기 때문에 외부 단편화와 압축의 문제를 발생시키지 않습니다.
- 공통의 코드를 공유할 수 있습니다. 코드가 재진입 코드인 경우에만 공유할 수 있는데 재진입 코드는 수정할 수 없고, 읽기만 가능하므로 두 개 이상의 프로세스에서 접근하더라도 안전하므로 코드를 공유할 수 있습니다.

#### **단점**

- 내부 단편화의 문제를 해결할 수 없습니다.
- 각 프로세스별 페이지 테이블을 가지기 때문에 추가적인 메모리가 소요됩니다.
- 물리 메모리에 접근하기 위해서는 2번의 접근이 필요하므로 이는 오버헤드가 증가하여 접근 시간은 2배로 느려지게 됩니다.

#### **페이지 테이블**

- 페이지 테이블은 각 프로세스마다 존재하며, 메인 메모리에 적재되어 있습니다. 페이지 테이블의 크기는 대부분 매우 크기 때문에 이를 구현하기 위해 비싼 레지스터를 사용하는 것은 적절하지 않습니다. 따라서 페이지 테이블은 메인 메모리에 적재하고 Page-Table Base Register(PTBR)을 사용하여 페이지 테이블을 가리키도록 합니다. 만약 context-switch가 발생하는 경우 PTBR의 내용만 변경하면 됩니다.

#### **페이지 테이블의 보호**

- 페이지 테이블의 각 엔트리에는 유효/무효 비트가 하나 더 있습니다. 
- 비트가 유효로 설정되면 관련된 페이지가 프로세스의 합법적인 페이지임을 나타냅니다.
- 비트가 무효로 설정되면 관련된 페이지가 프로세스의 논리 주소 공간에 속하지 않는다는 것을 의미합니다.
- 운영체제는 이러한 비트를 사용하여 프로세스별 메모리를 보호하게 됩니다.

#### **Translation Look Aside Buffer(TLB)**

- 페이징을 사용하면 물리 메모리에 접근하기 위해서는 2번의 엑세스가 필요로 하게됩니다. 그렇게 된다면 2배의 지연시간을 발생시키므로 이는 성능적으로 좋지 않는데 이 문제를 TLB를 사용하여 해결할 수 있습니다.
- TLB는 메모리 주소를 변환하기 위한 별도의 하드웨어 장치입니다. TLB는 페이지 테이블에서 빈번히 발생하는 일부 엔트리를 캐싱하고 있습니다.
- TLB는 key-value 쌍으로 데이터를 관리하는 연관 메모리로 구성되며, key에는 페이지번호, value에는 프레임 번호가 적재되어 있습니다.
- CPU는 우선 페이지 테이블보다 TLB를 우선적으로 참조하게 되며, 만약 여기서 얻고자하는 내용이 없다면 메인 메모리에 상주하고 있는 페이지 테이블에 접근하고 그렇지 않다면 바로 얻을 수 있습니다.
- TLB에서 엔트리를 검색할 때 TLB의 전체를 다 검색해야하지만 병렬 검색이 가능하므로 시간을 단축할 수 있습니다.

<img width="946" alt="스크린샷 2023-04-13 오후 8 25 01" src="https://user-images.githubusercontent.com/80187200/231744365-92e70527-8a55-48d4-ba9d-8bcacb282edb.png">

#### **TLB에서 context-switch**

- TLB의 각 항목에 ASIDs(Address-space identifiers)이라는 것을 저장하고 있는데, ASID는 TLB 항목이 어느 프로세스에 속한 것인지 알려주며, 해당 프로세스를 보호하기 위해 사용됩니다. TLB에서 
논리 주소를 변환할 때 현재 수행중인 프로세스의 ASDI가 TLB 항목에 있는 ASID와 같은지 검사합니다. 만약 일지하지 않으면 TLB 미스로 처리하게 됩니다.
- TLB에서 ASID의 지원이 없다면 context-switch가 발생할 때마다 다음 프로세스가 잘 실행될 수 있도록 TLB의 정보를 모두 flush해줘야 합니다. 그렇지 않으면 다음에 실행될 프로세스가 이전에 실행된 프로세스가 사용하던 페이지 번호와 프레임 번호가 남아 무효가 된 주소를 공급해줄 수 있습니다.

<br>

### **페이지 테이블 구조**
<hr>






















