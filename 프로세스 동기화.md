### **서론**
<hr>

- 협렵적 프로세스란 시스템이 실행중에 다른 프로세스와 협려과여 다른 프로세스에 영향을 주거나, 영향을 받는 프로세스입니다.
- 협력적 프로세스는 논리 주소 공간(코드나 데이터)을 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있는데 이러한 공유 데이터를 
공유하면 일관성이 깨질 수 있습니다. 그렇기 때문에 우리는 어떻게 공유 데이터에 대해 일관성을 보장할 수 있는지 살펴볼 필요성이 있습니다.

<br>

### **Race Condition이란**
<hr>

- race condition이란 두 개 이상의 프로세스 또는 스레드가 하나의 리소스에 접근하여 타이밍이나 순서 등의 원인으로 최종적 결과값에 영향을 미치는 것입니다.


##### **Race Condition이 발생할 수 있는 코드**
 <details>
<summary>코드 살펴보기</summary>

> 스레드 풀을 사용하여 2개의 스레드를 생성합니다. 이때 T1 스레드와 T2 스레드가 동시에 count 변수에 접근하면 동일한 값을 증가시키게 됩니다. 즉 
두 스레드가 공유 데이터(count)에 접근하여 race condition이 발생하게 됩니다.
  
> 
```
public class Counter {

    private int count = 0;

    public void increment() {
        this.count++;
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionTest {

    private static final ExecutorService executor = Executors.newFixedThreadPool(2);

    @Test
    void example() throws InterruptedException {

        Counter counter = new Counter();
        int threadCount = 1000;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            CompletableFuture.runAsync(() -> {
                try {
                    counter.increment();
                } finally {
                    latch.countDown();
                }
            }, executor);
        }
        latch.await();

        assertThat(counter.getCount()).isEqualTo(threadCount);
    }
}
  ```
</details>

<br>

### **Critical Section이란**
<hr>

- Critical Section이란 임계 구역입니다. 각 프로세스에는 Critical Section 부분을 포함하고 있습니다. Critical Section에서는 공유 데이터에 접근하고, 값을 갱신할 수 있습니다.
- 하나의 프로세스 또는 스레드가 Critical Section에 접근하여 수행되는 동안 다른 프로세스나 스레드는 Critical Section에 접근할 수 없습니다.
즉 동시에 두개 이상의 프로세스나 스레드는 Critical Section에 접근할 수 없습니다.
- 프로세스나 스레드는 Critical Section에 진입하기 위해서는 진입 허가를 요청해야 합니다. 이러한 요청을 구현하는 코드 부분을 진입 영역이라하고, 그 뒤에는 퇴출 구역이 있습니다.
- 운영체제 내에서 Critical Section을 다루기 위해서 선점형 커널과 비선점형 커널이 있습니다.
  
#### **선점형 커널이란**

- 프로세스나 스레드가 커널 모드에서 수행되는 동안 선점될 수 있습니다.
  
#### **비선점형 커널이란**

- 커널모드에서 수행되는 프로세스나 스레드는 선점을 허용하지 않고, 해당 프로세스나 스레드가 커널 모드를 빠져나갈 때까지 봉쇄되거나, 자발적으로 CPU 제어를 
양보할 때까지 계속 수행됩니다. (종료되거나 대기 큐에 적재되기 전까지)
  
#### **Critical Section의 문제 해결 조건**

- 임계구역의 문제를 해결하기 위해서는 3 가지 조건을 충족해야 합니다.
  
##### **상호 배제**

- 하나의 프로세스 또는 스레드가 임계구역에 진입하면 다른 프로세스 또는 스레드는 접근할 수 없습니다.
  
##### **진행**
  
- 임계구역에 진입한 프로세스나 스레드가 없는 상태에서 진입하고자 하는 프로세스나 스레드가 여러개 있다면 어느 프로세스나 스레드가 진입할지 결정해줘야 합니다.
또한 이 결정은 무한정 연기될 수 없습니다.
  
##### **한정된 대기**
  
- 하나의 프로세스나 스레드가 임계구역에 진입한 뒤 오랫동안 나오지 않으면 다른 프로세스나 스레드는 접근할 수 없게됩니다. 이러한 기아 상태를 방지하고자
 한 번 임계구역에 진입한 프로세스나 스레드가 다음에 진입할 때 제한을 둬야 합니다.
  
<br>

### **Mutex Lock이란**
<hr>
  
- 프로세스나 스레드가 Critical Section에 진입하기 위해서는 반드시 Lock을 획득하고, 빠져나올 때 해당 Lock을 반환해야 합니다.
- Mutex Lock은 available 이라는 변수를 가지는데, 이 available 변수의 값이 Lock의 가용 여부를 나타냅니다. 만약 Lock이 사용가능하다면 
acquire() 메서드를 호출하여 Lock을 획득하고 다른 프로세스나 스레드가 접근하지 못하도록 Lock을 가용불가 상태로 변경하게 됩니다.
- 사용 불가 상태의 Lock을 획득하려고 시도하는 프로세스나 스레드는 Lock이 가용상태가 될때까지 대기하게 됩니다.
- Mutex Lock의 단점은 busy waiting 입니다. 프로세스나 스레드가 Lock을 획득하여 임계구역에 있는 동안 임계구역에 들어가고자 하는 다른 프로세스나
스레드는 반복문을 통해 계속하여 qcquire 메서드를 호출하게 됩니다. Lock이 가용해지길 기다리면서 계속하여 반복 회전하고 있으므로 Spin Lock이라고도 합니다.
이러한 busy waiting은 CPU Cycle을 낭비하게 됩니다.
  
![스크린샷 2023-03-22 오후 9 51 55](https://user-images.githubusercontent.com/80187200/226910062-acaf5692-4f59-4249-aa61-335385b4cff8.png)

<br>

### **Semaphore란**
<hr>
  
- 세마포어는 Signaling 매커니즘이라는 점에서 Mutex Lock과 다릅니다. 세마포어는 Lock을 걸지 않은 스레드도 signal을 보내 락을 해제할 수 있습니다.
- 세마포어는 이진 세마포어와 카운팅 세마포어로 나뉩니다.
  
#### **이진 세마포어란**

- 이진 세마포어의 값은 0과 1만 가능합니다. 이진 세마포어는 Mutex Lock과 비슷하게 동작합니다.
- 만약 어떤 프로세스나 스레드가 Lock을 사용할 수 없으면 0(false)이고, 사용할 수 있으면 1(true)입니다. 이렇게 0 또는 1의 값만 갖는 세마포어를 이진 세마포어라 합니다.
  
#### **카운팅 세마포어란**
  
- 카운팅 세마포어는 0과 1뿐만 아니라 0, 1, 2, 3, 4, 5... 등의 값을 가질 수 있는, 즉 도메인 제한이 없는 카운팅 세마포어 입니다.
- 예를들어 주문을 접수받는 키오스크가 5개 있습니다. 이때 사용자가 주문을 접수하고자 서버에 요청을 하면 키오스크가 5개 있으므로 공유 자원은 5개로 설정됩니다.
그리고 사용자가 키오스크를 사용할 때마다 그 값은 하나씩 감소하게 됩니다. 그러다 사용하고자 하는 키오스크가 없어지면 0이되고, 누군가 키오스크를 반납하면 다시 1이 증가됩니다.
이런식으로 세마포어 변수는 공유 자원의 개수를 나타내는 변수입니다.
- 카운팅 세마포어는 유한한 개수를 가진 자원에 대한 접근을 제어하는데 사용될 수 있습니다. 세마포어는 가용한 자원의 개수로 초기화됩니다. 위의 예를통해 이해할 수 있습니다.

##### **wait메서드와 signal 메서드**

- wait 메서드와 signal 메서드는 연산 시 세마포어의 정수값을 변경하는 연산은 반드시 원자적으로 수행되어야 합니다. 즉 하나의 프로세스 또는 스레드가
 세마포어의 값을 변경하면, 다른 어떤 프로세스나 스레드가 동시에 동일한 세마포어의 값을 변경할 수 없습니다.
- 세마포어의 변수 S는 초기화를 제외하면 atomic operation인 wait, signal 메서드로만 접근할 수 있습니다.
- wait 메서드는 공유 자원을 확인하여 사용 가능한 공유 자원이 없으면 wait(대기)입니다. 반면 사용 가능한 공유 자원이 있으면 signal 입니다.
  
##### **Mutex Lock과 Semaphore의 차이점은 뭘까?**

- 세마포어에는 이진 세마포어가 있습니다. 그렇기 때문에 세마포어는 뮤텍스가 될 수 있지만, 반대로 뮤텍스는 세마포어가 될 수 없습니다. 그 이유는 세마포어에는 카운팅 세마포어도 있기 때문입니다.
- 동기화의 개수입니다. 뮤텍스는 동기화의 대상이 오직 하나이지만, 세마포어는 동기화 대상이 하나 이상일때 사용됩니다.
- 뮤텍스 락은 Locking 매커니즘으로 락을 걸은 프로세스나 스레드만이 임계구역을 나갈때 락을 해제할 수 있습니다. 반면 세마포어는 Signaling 매커니즘으로 
락을 걸지 않은 스레드들도 signal을 보내 락을 해제할 수 있습니다.
  
##### **Semaphore의 장단점**
 
###### **장점**

- 프로세스나 스레드가 Critical Section에 접근할 수 있도록 조건이 충족되었는지 확인하기 위해 시간이 불필요하게 낭비되지 않기 때문에 busy waiting으로 인한 자원 낭비가 발생하지 않습니다.
  
###### **단점**
  
- 세마포어는 우선순위가 낮은 프로세스나 스레드가 Critical Section에 먼저 접근하고 우선순위가 높은 프로세스나 스레드가 나중에 접근할 수 있는 우선순위 역전이 발생할 수 있습니다.
- 세마포어의 DeadLock을 방지하기 위해서는 wait 및 signal 작업이 올바른 순서로 실행되어야 합니다.
  
 ##### **Semaphore는 어떻게 동작할까?**
 
 - 카운팅 세마포어로 예를들어보면, 3개의 공유자원을 사용할 수 있다는 가정하에 Critical Section에는 이미 P1, P2, P3의 프로세스로 인해 더 이상 가용할 수 있는 자원이 없습니다. 이때 P4가 Critical Section에 진입하고자 한다면 가용할 자원이 없으므로 Waiting Queue에서 대기하게 됩니다. 그리고 시간이 지나 Critical Section에 접근할 가용할 자원이 생긴다면 Waiting Queue에서 기다리고 있던 P4가 Critical Section에 진입하게 됩니다.
- 또한 실행중인 프로세스가 signal operation을 수행하게 되면 Waiting Queue에서 대기하고 있던 하나의 프로세스가 깨어나게 됩니다. 그리고 가용할 수 있는 자원이 +1이 되어 깨어난 프로세스는 Critical Section에 진입하게 됩니다.
 
 ![스크린샷 2023-03-23 오후 10 09 49](https://user-images.githubusercontent.com/80187200/227214240-50ae634a-1712-4fe0-8b05-2bfbfa2b5cde.png)

<br>

### **Monitor란**
<hr>
 
- 세마포어는 프로세스난 스레드간 동기화를 위해서 편리하고 효과적으로 사용될 수는 있지만 세마포어를 자칫 잘못 사용하면 발견하기 어려운 타이핑 오류를 야기할 수 있습니다. 이런 타이핑 오류는 특정 실행 순서로 진행되었을 때만 발생하고, 이러한 순서가 항상 일어나는 것은 아니기 때문입니다.
- 세미포어는 wait & signal 연산 순서를 바꿔 실행하거나 wait & wait 순서로 구성되어 있으면 교착 상태가 발생하게 됩니다. 또한 wait & signal이 시스템 전체에 구성되어 있으면 세마포어의 영향이 미치는 곳이 어딘지 파악하기 힙듭니다. 이러한 단점을 극복하기 위해 모니터가 등장하게 되었습니다.
- 모니터는 임계구역을 지켜내기 위한 방법인 상호 배제 방법으로 구현했으며, 이진 세마포어만 가능합니다.
 
#### **모니터의 개념**

- 하나의 객체마다 하나의 모니터를 결합할 수 있습니다. 모니터는 객체가 동시에 두 개 이상의 스레드에 접근할 수 없도록 Lock을 제공함으로써 동기화를 수행하는 동기화 도구 입니다.
- 객체에 모니터를 결합하면 하나의 스레드가 해당 객체를 사용하고 있는 동안 다른 스레드들이 객체를 사용할 수 없게 됩니다.
- 자바에서는 synchronized 키워드로 구현할 수 있습니다.
 
#### **모니터의 구조**
 
 ![스크린샷 2023-03-23 오후 10 15 03](https://user-images.githubusercontent.com/80187200/227215465-57f89295-2ba2-443f-b9b4-edaa99a99c8e.png)

##### **상호 배타 큐**

- 공유 자원에 하나의 프로세스만 집입하도록 하기 위한 큐입니다.
- 특정 스레드가 공유 자원을 사용하는 함수를 사용하고 있으면 다른 스레드는 접근할 수 없고, 상호 배타 큐에서 대기해야 합니다.
 
##### **조건 대기 큐**
 
- 공유 자원의 Lock이 해제되길 기다리는 스레드가 대기하는 큐입니다.
- 진입 스레드가 블록되면서 새 스레드가 진입가능하게 하는 큐입니다. 새 스레드는 조건 동기로 인해 블록된 스레드를 깨울 수 있습니다.
이렇게 깨워진 스레드는 현재 스레드가 나가면 재진입할 수 있습니다.
 
#### **자바에서 모니터의 원리**
 
- 상호 배타 큐는 자바에서 synchronized 키워드를 사용해 지정할 수 있습니다. 반면 조건 동기 큐는 wait, notify, notifyAll 메서드를 사용합니다.
- 자바에서 synchronized 키워드가 사용된 메서드에 접근하기 위해서는 상호 배타 큐에 적재됩니다.
- 조건 동기 큐의 경우 wait 메서드를 실행하면 진입한 스레드를 조건 동기 큐에 블록 시킵니다. 그리고 notify, notifyAll 메서드를 사용하여 깨우고 
다시 임꼐 구역에 오도록 합니다.
 
 ![스크린샷 2023-03-23 오후 10 19 45](https://user-images.githubusercontent.com/80187200/227216598-7eda4118-fd96-44f6-a53d-4c605286fa9d.png)

##### **wait 메서드**
 
- wait 메서드는 오직 synchronized 블록 내에서만 호출 가능합니다. wait 메서드의 기능은 객체가 가지고 있는 Lock을 release 하는 것이기 때문에 만약 wait를 호출하는 스레드가 Lock을 소유하고 있지 않다면 예외가 발생합니다.
- Lock을 release하는 것을 조금 더 정확히 표현하면 제어권을 다른 스레드에게 넘겨주는 것입니다. 그리고 release한 스레드는 조건 동기 큐에 적재됩니다.
- wait 메서드를 호출하면 Lock을 소유하고 있던 스레드는 Lock을 release하면서 WAITING 또는 TIMED_WAITING 상태로 변하게 되면서 조건 동기 큐에 적재되는데 여기에 적재된 스레드들은 notify나 notifyAll 메서드를 호출함으로써 다시 임계구역으로 이동하게 됩니다.
 
 ##### **notify, notifyAll 메서드**
 
- wait 메서드에 의해 조건 동기 큐에 적재된 스레드를 깨우기 위해서는 notify나 notifyAll 메서드를 사용하여 스레드를 깨울 수 있습니다.
