### **서론**
<hr>

- 협렵적 프로세스란 시스템이 실행중에 다른 프로세스와 협려과여 다른 프로세스에 영향을 주거나, 영향을 받는 프로세스입니다.
- 협력적 프로세스는 논리 주소 공간(코드나 데이터)을 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있는데 이러한 공유 데이터를 
공유하면 일관성이 깨질 수 있습니다. 그렇기 때문에 우리는 어떻게 공유 데이터에 대해 일관성을 보장할 수 있는지 살펴볼 필요성이 있습니다.

<br>

### **Race Condition이란**
<hr>

- race condition이란 두 개 이상의 프로세스 또는 스레드가 하나의 리소스에 접근하여 타이밍이나 순서 등의 원인으로 최종적 결과값에 영향을 미치는 것입니다.


##### **Race Condition이 발생할 수 있는 코드**
 <details>
<summary>코드 살펴보기</summary>

> 스레드 풀을 사용하여 2개의 스레드를 생성합니다. 이때 T1 스레드와 T2 스레드가 동시에 count 변수에 접근하면 동일한 값을 증가시키게 됩니다. 즉 
두 스레드가 공유 데이터(count)에 접근하여 race condition이 발생하게 됩니다.
  
> 
```
public class Counter {

    private int count = 0;

    public void increment() {
        this.count++;
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionTest {

    private static final ExecutorService executor = Executors.newFixedThreadPool(2);

    @Test
    void example() throws InterruptedException {

        Counter counter = new Counter();
        int threadCount = 1000;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            CompletableFuture.runAsync(() -> {
                try {
                    counter.increment();
                } finally {
                    latch.countDown();
                }
            }, executor);
        }
        latch.await();

        assertThat(counter.getCount()).isEqualTo(threadCount);
    }
}
  ```
</details>

<br>

### **Critical Section이란**
<hr>

- Critical Section이란 임계 구역입니다. 각 프로세스에는 Critical Section 부분을 포함하고 있습니다. Critical Section에서는 공유 데이터에 접근하고, 값을 갱신할 수 있습니다.
- 하나의 프로세스 또는 스레드가 Critical Section에 접근하여 수행되는 동안 다른 프로세스나 스레드는 Critical Section에 접근할 수 없습니다.
즉 동시에 두개 이상의 프로세스나 스레드는 Critical Section에 접근할 수 없습니다.
- 프로세스나 스레드는 Critical Section에 진입하기 위해서는 진입 허가를 요청해야 합니다. 이러한 요청을 구현하는 코드 부분을 진입 영역이라하고, 그 뒤에는 퇴출 구역이 있습니다.
- 운영체제 내에서 Critical Section을 다루기 위해서 선점형 커널과 비선점형 커널이 있습니다.
  
#### **선점형 커널이란**

- 프로세스나 스레드가 커널 모드에서 수행되는 동안 선점될 수 있습니다.
  
#### **비선점형 커널이란**

- 커널모드에서 수행되는 프로세스나 스레드는 선점을 허용하지 않고, 해당 프로세스나 스레드가 커널 모드를 빠져나갈 때까지 봉쇄되거나, 자발적으로 CPU 제어를 
양보할 때까지 계속 수행됩니다. (종료되거나 대기 큐에 적재되기 전까지)
  
#### **Critical Section의 문제 해결 조건**

- 임계구역의 문제를 해결하기 위해서는 3 가지 조건을 충족해야 합니다.
  
##### **상호 배제**

- 하나의 프로세스 또는 스레드가 임계구역에 진입하면 다른 프로세스 또는 스레드는 접근할 수 없습니다.
  
##### **진행**
  
- 임계구역에 진입한 프로세스나 스레드가 없는 상태에서 진입하고자 하는 프로세스나 스레드가 여러개 있다면 어느 프로세스나 스레드가 진입할지 결정해줘야 합니다.
또한 이 결정은 무한정 연기될 수 없습니다.
  
##### **한정된 대기**
  
- 하나의 프로세스나 스레드가 임계구역에 진입한 뒤 오랫동안 나오지 않으면 다른 프로세스나 스레드는 접근할 수 없게됩니다. 이러한 기아 상태를 방지하고자
 한 번 임계구역에 진입한 프로세스나 스레드가 다음에 진입할 때 제한을 둬야 합니다.
  
<br>

### **Mutex Lock이란**
<hr>
  
- 프로세스나 스레드가 Critical Section에 진입하기 위해서는 반드시 Lock을 획득하고, 빠져나올 때 해당 Lock을 반환해야 합니다.
- Mutex Lock은 available 이라는 변수를 가지는데, 이 available 변수의 값이 Lock의 가용 여부를 나타냅니다. 만약 Lock이 사용가능하다면 
acquire() 메서드를 호출하여 Lock을 획득하고 다른 프로세스나 스레드가 접근하지 못하도록 Lock을 가용불가 상태로 변경하게 됩니다.
- 사용 불가 상태의 Lock을 획득하려고 시도하는 프로세스나 스레드는 Lock이 가용상태가 될때까지 대기하게 됩니다.
- Mutex Lock의 단점은 busy waiting 입니다. 프로세스나 스레드가 Lock을 획득하여 임계구역에 있는 동안 임계구역에 들어가고자 하는 다른 프로세스나
스레드는 반복문을 통해 계속하여 qcquire 메서드를 호출하게 됩니다. Lock이 가용해지길 기다리면서 계속하여 반복 회전하고 있으므로 Spin Lock이라고도 합니다.
이러한 busy waiting은 CPU Cycle을 낭비하게 됩니다.
  
![스크린샷 2023-03-22 오후 9 51 55](https://user-images.githubusercontent.com/80187200/226910062-acaf5692-4f59-4249-aa61-335385b4cff8.png)

<br>

### **Semaphore란**
<hr>
  
- 세마포어는 Signaling 매커니즘이라는 점에서 Mutex Lock과 다릅니다. 세마포어는 Lock을 걸지 않은 스레드도 signal을 보내 락을 해제할 수 있습니다.
- 세마포어는 이진 세마포어와 카운팅 세마포어로 나뉩니다.
  
#### **이진 세마포어란**

- 이진 세마포어의 값은 0과 1만 가능합니다. 이진 세마포어는 Mutex Lock과 비슷하게 동작합니다.
- 만약 어떤 프로세스나 스레드가 Lock을 사용할 수 없으면 0(false)이고, 사용할 수 있으면 1(true)입니다. 이렇게 0 또는 1의 값만 갖는 세마포어를 이진 세마포어라 합니다.
  
#### **카운팅 세마포어란**
  
- 카운팅 세마포어는 0과 1뿐만 아니라 0, 1, 2, 3, 4, 5... 등의 값을 가질 수 있는, 즉 도메인 제한이 없는 카운팅 세마포어 입니다.
- 예를들어 주문을 접수받는 키오스크가 5개 있습니다. 이때 사용자가 주문을 접수하고자 서버에 요청을 하면 키오스크가 5개 있으므로 공유 자원은 5개로 설정됩니다.
그리고 사용자가 키오스크를 사용할 때마다 그 값은 하나씩 감소하게 됩니다. 그러다 사용하고자 하는 키오스크가 없어지면 0이되고, 누군가 키오스크를 반납하면 다시 1이 증가됩니다.
이런식으로 세마포어 변수는 공유 자원의 개수를 나타내는 변수입니다.
- 카운팅 세마포어는 유한한 개수를 가진 자원에 대한 접근을 제어하는데 사용될 수 있습니다. 세마포어는 가용한 자원의 개수로 초기화됩니다. 위의 예를통해 이해할 수 있습니다.

##### **wait메서드와 signal 메서드**

- wait 메서드와 signal 메서드는 연산 시 세마포어의 정수값을 변경하는 연산은 반드시 원자적으로 수행되어야 합니다. 즉 하나의 프로세스 또는 스레드가
 세마포어의 값을 변경하면, 다른 어떤 프로세스나 스레드가 동시에 동일한 세마포어의 값을 변경할 수 없습니다.
- 세마포어의 변수 S는 초기화를 제외하면 atomic operation인 wait, signal 메서드로만 접근할 수 있습니다.
- wait 메서드는 공유 자원을 확인하여 사용 가능한 공유 자원이 없으면 wait(대기)입니다. 반면 사용 가능한 공유 자원이 있으면 signal 입니다.
  
##### **Mutex Lock과 Semaphore의 차이점은 뭘까?**

- 세마포어에는 이진 세마포어가 있습니다. 그렇기 때문에 세마포어는 뮤텍스가 될 수 있지만, 반대로 뮤텍스는 세마포어가 될 수 없습니다. 그 이유는 세마포어에는 카운팅 세마포어도 있기 때문입니다.
- 동기화의 개수입니다. 뮤텍스는 동기화의 대상이 오직 하나이지만, 세마포어는 동기화 대상이 하나 이상일때 사용됩니다.
- 뮤텍스 락은 Locking 매커니즘으로 락을 걸은 프로세스나 스레드만이 임계구역을 나갈때 락을 해제할 수 있습니다. 반면 세마포어는 Signaling 매커니즘으로 
락을 걸지 않은 스레드들도 signal을 보내 락을 해제할 수 있습니다.
  
  
  
  
  
  
  
  
  
  
