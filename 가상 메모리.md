### **가상 메모리란**
<hr>

- 가상 메모리란 프로세스 전체가 물리 메모리내에 올라오지 않아도 실행가능하다는것을 의미합니다.
- 애플리케이션이 실행될 때, 실행에 필요한 부분만 물리 메모리에 적재되고, 나머지 부분은 보조저장장치에 남게됩니다. 이렇게 물리 메모리와 보조저장장치를 병합하여
하나의 가상 메모리처럼 동작하게 하는것입니다.
- 가상 메모리를 구현하기 위해서는 컴퓨터가 특수한 하드웨어 장치를 가지고 있어야 하는데 이를 MMU라고 합니다.
- MMU는 논리 주소에 임의의 값을 더해 물리 메모리에 접근할 수 있도록 도와주는 장치입니다.

<br>

### **요구 페이징**
<hr>

- 요구 페이징은 가상 메모리 시스템에 일반적으로 사용되며, 처음 모든 페이지가 물리 메모리에 적재되어 있지 않고, 필요한 일부 데이터만 물리 메모리에 적재한 후 나머지 데이터는 보조저장장치에 있습니다.
- 데이터가 물리 메모리에 있는지, 보조저장장치에 있는지 구분하기 위해서는 하드웨어의 지원이 필요합니다. 무효/유효 비트를 사용하여 구분할 수 있습니다.
- 비트가 유효하다고 설정되면 해당 페이지가 물리 메모리에 있다는 의미이고, 비트가 무효하다고 설정되면 해당 페이지가 가상 주소 공간에 존재하지 않거나, 유효하지만 보조저장장치에 존재한다는 것을 의미합니다.

#### **페이지 폴트**

- 페이지 폴트란 프로세스가 메모리에 올라와있지 않는 페이지에 접근하고자할 때 발생하게 됩니다. 페이지 폴트가 발생하면 운영체제가 이를 해결한뒤 명령어를 재실행하게 됩니다.

![스크린샷 2023-04-25 오후 10 03 27](https://user-images.githubusercontent.com/80187200/234284937-85609e35-58fb-44ea-8dbd-ddeb3836b170.png)

##### **페이지 폴트 과정**

1. 프로세스가 페이지 테이블을 검사하여 해당 메모리 참조의 무효/유효 비트를 확인합니다. 
2. 무효비트라면 트랩을 발생시킵니다. 유효비트더라도 메모리에 없다면 트랩을 발생시킵니다.
3. 유효비트인데 페이지가 보조저장장치에 있다면 보조저장장치에 접근합니다.
4. 보조저장장치로부터 가져옵니다. 또한 물리 메로이에서 가용한 프레임을 찾으며, 해당 프레임에 채웁니다.
5. 해당 페이지가 메모리에 있다는것을 알리기위해 페이지 테이블을 갱신합니다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행합니다. 이제 프로세스는 마치 그 페이지가 항상 메모리에 있던거처럼 해당 페이지에 접근할 수 있습니다.

#### **순수 요구 페이징**

- 극단적인 경우 메모리에 페이지가 하나도 올라와 있지않은 상태에서도 프로세스를 실행시킬 수 있습니다.
- 운영체제에서 명령어 포인터의 값을 프로세스의 첫 명렁으로 실행하는 순간 해당 명령이 메모리에 존재하지 않기 때문에 페이지 폴트가 발생하게 됩니다. 또한 
페이지가 적재되고 나면 프로세스는 다시 수행을 이어나갈텐데 또 필요한 데이터가 있다면 페이지 폴트를 발생시킵니다. 이렇게 필요한 모든 페이지가 적재되고 나면
더 이상 페이지 폴트가 발생하지 않는데, 이 과정을 순수 요구 페이징이라 합니다. 즉 어떤 페이지가 필요해지기 전꺼지 결코 그 페이지를 메모리에 적재하지 않는 방법입니다.

#### **가용 프레임 리스트**

- 페이지 폴트가 발생하면 운영체제는 요청된 페이지를 보조저장장치에서 메인 메모리로 가져와야 합니다. 페이지 폴트를 해결하기 위해 대부분의 운영체제는 가용프레임 풀인 가용 프레임 리스트를 유지합니다.
- 운영체제는 일반적으로 zero-fill-on-demand 라는 기법을 사용하여 가용 프레임을 할당합니다. zero-fill-on-demand 프레임은 할당하기 전에 0 으로 모두 채워져 이전 내용이 지워집니다.
- 시스템이 시작되면서 모든 가용 메모리가 가용 프레임 리스트에 채워집니다. 가용 프레임이 요청되면 가용 프레임 리스트에서 하나를 할당하게 되며, 크기가 줄어듭니다.

<br>

### **쓰기 시 복사(copy on write)**
<hr>

- 요구 페이징 및 순수 요구 페이징을 통해 프로세스를 빠르게 실행시킬 수 있다는 것을 알게되었습니다. 그러나 fork 시스템 콜을 통해 프로세스를 생성할 때는 첫 요구 페이징조차 생략할 수 있습니다.
- 쓰기 시 복사를 통해 프로세스 생성 시간이 더 줄어들 수 있고, 새로 생성된 프로세스에게 새롭게 할당되어야 하는 페이지의 수도 줄일 수 있습니다.
- fork 시스템 콜을 하면 부모 프로세스의 페이지들을 자식 프로세스에게 복사해줌으로써 자식 프로세스의 주소 공간을 구성해주었는데 이 방법은 상당히 비효율적입니다.
그 이유는 자식 프로세스들은 만들어지자마자 exec 시스템 콜을 합니다.

#### **copy on write**

- copy on write 방식은 자식 프로세스를 생성할 때 부모 페이지를 당분간 공유하는 방식입니다. 이때 공유되는 페이지를 copy on write라고 표시합니다.
둘 중 한 프로세스가 공유 중인 페이지에 쓸 때 그 페이지의 복사본이 만들어진다는 의미입니다.
- 운영체제는 가용 프레임 리스트에서 프레임을 얻고, 이 페이지의 복사본을 만들어 자식 프로세스의 주소 공간에 사상시킵니다. 따라서 자식은 그 개인용으로 만든
페이지에 수정을 하게 됩니다. 이렇게 하면 수정하는 페이지에 대해서만 복사본이 생기고, 수정하지 않은 페이지는 공유될 수 있습니다.

![스크린샷 2023-04-25 오후 10 17 37](https://user-images.githubusercontent.com/80187200/234288580-c9464ebe-8759-44a9-97c1-d5dd93646fdb.png)

#### **copy on write과 vfork 시스템 콜**

- vfork 시스템 콜을 하면 부모 프로세스는 보류되고, 자식이 부모 주소 공간을 사용하게 됩니다. 하지만 vfork 시스템 콜은 copy on write를 사용하지 않으므로 
자식이 부모 주소 공간에 페이지를 수정하게 되면 변경된 페이지가 부모 프로세스가 재실행될 때 보여지게 됩니다. 따라서 vfork 시스템 콜을 사용할 때에는 자식이 
부모의 페이지에 변경을 하지 않도록 조심해야 합니다.

<br>

### **페이지 교체**
<hr>

- 프로세스가 실행되는 동안 페이지 폴트가 발생하게 됩니다. 운영체제는 필요로 하는 페이지가 보조저장장치에 저장된 위치를 알아내어 물리 메모리의 가용 프레임에 올릴려고 하지만
가용 프레임이 없음을 발견합니다. 이때 운영체제는 몇가지 선택을 할 수 있습니다. 예를들어 다른 프로세스를 종료한다던가, 스와핑 기법을 사용한다던가 할 수 있지만
이는 오버헤드를 유발하게 됩니다. 그렇기 때문에 대부분의 운양체제는 페이지 교체 기법을 사용하게 됩니다.

![스크린샷 2023-04-25 오후 10 21 32](https://user-images.githubusercontent.com/80187200/234289603-20270edc-1f46-464c-818d-0cc5751d9e51.png)

#### **페이지 교체 과정**

1. 보조자장장치에서 필요한 페이지의 위치를 알아냅니다.
2. 물리 메모리에서 가용한 프레임을 찾습니다.
   1. 가용한 프레임이 존재한다면 해당 프레임을 사용합니다.
   2. 가용 프레임이 없다면 희생될 프레임을 선정하기 위해 페이지 교체 알고리즘을 가동시킵니다.
   3. 희생될 프레임을 보조저장장치에 기록하고, 관련된 데이터를 물리 메모리에 적재합니다.
3. 가용한 프레임이 생겼으니 저장하고, 페이지 테이블을 갱신합니다.
4. 페이지 폴트가 발생한 지점부터 다시 프로세스를 재개합니다.
















































<br>

### **질문**

#### **동적 적재와 가상 메모리의 차이점이 뭘까?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **요구 페이징이란 무엇인가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **요구 페이징을 구현하기 위해서는 하드웨어의 지원이 필요한데, 여기서 하드웨어가 수행하는 역할이 무엇인가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **페이지 폴트란 무엇인지 설명할 수 있는가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **페이지 폴트의 과정을 설명할 수 있는가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **순수 요구 페이징을 설명할 수 있는가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **자식 프로세스 생성시 fork 시스템 콜을 호출하는데 여기서 어떻게 copy-on-write 기법을 사용할 수 있는가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **vfork 시스템콜과 copy-on-write에 대해서 설명할 수 있는거?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

<br>

#### **페이지 교체란 무엇인가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>

#### **페이지 교체 과정이 어떻게 이루어지는가?**
 <details>
<summary>나의 답변</summary>

> ... 
</details>
