### **프로세스란 무엇인가?**
<hr>

- 프로세스란 현재 메모리에서 실행중인 프로그램 및 태스크(작업)을 의미합니다.

<br>

### **프로세스는 어떻게 구성되어 있는가?**
<hr>

- 프로세스는 텍스트 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분되어 있습니다.
- 텍스트 영역은 실행 코드가 있으며, 여기에는 명령 및 상수가 포함되어 있습니다.
- 데이터 영역은 초기화되어 있지 않거나 초기화가 이루어진 전역 변수 및 전역 상수가 포함되어 있습니다.
- 힙 영역은 런타임시 생성되는 객체나 배열이 포함되어 있습니다.
- 스택 영역은 함수의 지역변수, 매개변수, 반환 주소가 포함되어 있습니다.
- 텍스트 영역, 데이터 영역은 고정된 크기를 가지고 있습니다. 그렇기 때문에 프로그램 실행시 동적으로 크기가 변하지 않습니다. 반면 힙 영역이나 스택 영역은 프로그램 실행시 동적으로 크기가 할당됩니다.

<br>

### **프로세스의 상태는 어떻게 구성되어 있는가?**
<hr>

- 프로세스의 상태는 생성 상태, 준비 상태, 실행 상태, 대기 상태, 종료 상태 총 5가지로 구분되어 있습니다.

#### **생성 상태**

- 프로세스가 생성중인 상태입니다. 이 상태에서는 프로세스에 대한 메모리 할당 및 프로세스의 PCB가 생성됩니다.

#### **준비 상태**

- 준비 상태는 프로세스 디스패치에 의해 자원이 할당되면 실행할 수 있는 상태입니다.
- 프로세스 디스패치는 준비 상태에 있는 여러 프로세스 중 적절한 프로세스를 찾아 CPU를 할당해줍니다.

#### **실행 상태**

- 실행 상태는 프로세스가 CPU를 사용하여 자신의 임루를 수행중인 상태입니다.
- 실행 상태에서 프로세스가 자신의 임무를 정상적으로 완료하면 종료 상태로 옮겨집니다.
- 실행 상태에서 비밀번호 입출력 등 I/O 작업이나 어떠한 이벤트를 기다리게 되는 경우 해당 프로세스는 대기 큐에 옮겨지며 대기 상태가 됩니다.
- 실행 상태에서 인터럽트에 의해 준비 상태로 옮겨질 수 있습니다.

#### **대기 상태**

- 실행 상태에 놓여진 프로세스가 비밀번호 입출력 등과 같은 I/O 작업이나 어떠한 이벤트로 인해 대기하게 되는 경우 대기 큐에 옮겨지며 해당 프로세스는 대기 상태가 됩니다.
이러한 대기 상태에 놓여진 프로세스는 I/O 작업이나 이벤트가 완료되면 준비 상태로 옮겨지게 됩니다.

<br>

### **프로세스 제어 블럭이 무엇인가?**
<hr>

- 프로세스 제어 블럭(PCB)는 운영체제가 프로세스를 관리하기 위해 만들어진 데이터 구조입니다.
- PCB는 프로세스가 생성되고 종료되면 소멸합니다. 운영체제는 PCB에 저장된 정보를 사용하여 프로세스 실행을 관리하고 올바르게 실행되도록 하는데 필요한 자원에 대한 접근할 수 있는지 확인합니다.


<br>

### **context switch란 무엇인가?**
<hr>

- 문맥 교환은 운영체제가 실행중인 프로세스를 저장하고 다른 프로세스를 로드하여 실행 시킨 후 다시 기존 프로세스로 돌아가 작업을 하는 것입니다.
- 일반적으로 커널 모드이건 사용자 모드이건 상관없이 PCB를 저장하는 작업을 수행하고 나중에 다시 실행할 수 있도록 복구 작업을 실행합니다.

#### **context switch가 필요한 이유가 뭘까?**

- context switch가 없다면 어떠한 프로세스가 CPU를 독점할 가능성이 있습니다. 그렇기 때문에 단일 프로세스가 CPU를 독점하는 것을 방지하기 위해 필요합니다.

#### **context switch의 장점?**

- context switch를 통해 한정적인 CPU를 최대한 사용하여 여러 프로세스나 스레드를 동시에 실행할 수 있습니다. 이렇게 효율성이나 생산성을 증가시킬 수 있습니다.
- context switch를 통해 여러 프로세스 또는 스레드가 CPU, 메모리 등과 같은 시스템 자원을 공유할 수 있습니다. 이는 자원의 낭비를 막을 수 있습니다.
- 앞서 언급한거처럼 프로세스가 독점적으로 CPU를 가지는 것을 방지할 수 있습니다.

#### **context switch의 단점?**

- 프로세스를 저장하고 복구하고 하는 작업에서 오버헤드가 발행하므로 성능이 저하됩니다.
- 프로세스를 저장하고 복구하는 작업에서 캐시 미스가 발생하여 있어야할 데이터가 없다면 운영체제는 프로세스를 다시 메모리에 데이터를 로드해야하므로 성능이 저하됩니다.

<br>

### **프로세스 연산에 대해**
<hr>

#### **프로세스 생성은 어떻게 되는가?**

- 생성하는 프로세스를 부모 프로세스라하고, 새로운 프로세스를 자식 프로세스라 합니다. 이러한 구조는 트리 구조를 가지게 됩니다.
- 일반적으로 프로세스가 자식 프로세스를 생성할 때 자식 프로세스는 수행해야할 임무에 대해 자원이 필요합니다. 이러한 자원은 운영체제로부터 할당 받거나 부모 프로세스가 가진 자원 중 부분 집합만 사용할 수 있도록 제한을 할 수 있습니다.
- 부모 프로세스는 자원을 분할하여 자신의 자식 프로세스에게 나누어 주거나 같이 사용할 수 있도록 할 수 있습니다. 또한 부모 프로세스는 자식 프로세스가 과도하게 생성되는 것을 방지할 수 있으며, 과부화 상태로 빠지는 것을 방지할 수 있습니다.


#### **프로세스 종료은 어떻게 되는가?**

- 자원을 할당받은 프로세스는 자신의 임무가 끝나면 종료됩니다.
- 부모 프로세스는 자식 프로세스를 종료하기 위해 PID를 알아야 하는데 자식 프로세스가 만들어지면 자식 프로세스의 PID는 부모 프로세스에게 전달됩니다.
- 부모 프로세스가 종료되면 자식 프로세스 또한 종료됩니다. 이를 연쇄적 종료라 합니다.

#### **좀비 프로세스란 무엇인가?**

- Unix 및 Unix와 비슷한 운영체제에서 좀비 프로세는 또는 소멸된 프로세스는 exit 시스템 호출로 인해 종료되었지만 여전히 프로세스 테이블에 남아있는 프로세스 입니다. 
- 보통 프로세스가 종료되면 바로 제거되는게 아니라 아주 짧은 시간이지만 남아 있게 됩니다. 그런 다음 부모 프로세느는 wait 시스템을 호출하여 좀비 프로세스 식별자와 프로세스 테이블을 읽은 다음 프로세스를 정리하고 프로세스 디스크립터를 해제하게 되는데 이 과정에도 불구하고 남은 프로세스 입니다.

#### **고아 프로세스란 무엇인가?**

- 고아 프로세스란 자식 프로세스는 자신의 임무를 수행하기 위해 실행중인 상태이지만 부모 프로세스가 종료된 프로세스입니다. 부모가 죽어 고아가된 프로세스는 init 프로세스가 주기적으로 wait 시스템을 호출하여 새로운 부모 프로세스를 지정해줍니다.

<br>

### **프로세스간 통신**
<hr>

- 운영체제 내에서 실행되는 프로세스는 독립적이거나 협력적으로 실행될 수 있습니다. 프로세스가 프로그램 내에서 다른 프로세스와 데이터를 공유하지 않는다면 독립적이고, 프로세스가 다른 프로세스와 협력한다면 협력적인 프로세스 입니다.

#### **공유 메모리 시스템에서의 프로세스간 통신**

- 공유 메모리 시스템이란 여러 프로세스나 스레드가 공유 메모리에 접근하여 데이터를 주고받는 시스템입니다.
- 공유 메모리 시스템은 shared memory segment라는 것을 사용합니다. 이러한 세그먼트는 다른 프로세스나 스레드와 공유하고자 하는 프로세스나 스레드가 운영체제에 있는 함수나 라이브러리를 호출하여 세그먼트를 만들고 이를 활용하여 통신을 하게 됩니다
- 운영체제는 기본적으로 다른 프로세스간의 메모리 접근을 제한하지만 공유 메모리 시스템은 이를 허용하는 것입니다.

#### **공유 메모리 시스템에서의 프로세스간 통신시 주의점**

- race condition이 발생할 수 있습니다. 그렇기 때문에 최종 결과에 영향을 미칠 수 있습니다.
- 메모리 부족 현상이 발생할 수 있습니다. 여러 프로세스나 스레드가 메모리를 공유하면서 전체적인 메모리 공간이 부족해질 수 있습니다.
- 캐시 일관성이 깨질 수 있습니다.

<br>

### **질문**

#### **자바에서 스택 세그먼트란 무엇인가요? 또한 스택 세그먼트로 인해 발생할 수 있는 오류는 어떤게 있을까요?**
 <details>
<summary>나의 답변</summary>

> 자바에서 스택은 Call Stack을 생각할 수 있지 않을까 생각합니다. main 함수에서 foo 함수를 호출하면 main 스택위에 foo 스택이 쌓이며 해당 스택에는 지역 변수, 매개변수, 반환 주소가 포함되어 있습니다. 또한 종료 조건없이 자신을 재귀적으로 호출한다던가 서로 참조하여 호출을 하게되는 경우 Stack Overflow가 발생할 수 있습니다.

</details>

<br>

#### **자바에서 힙 세그먼트란 무엇인가요?**

<details>
<summary>나의 답변</summary>

>자바에서 객체나 배열은 힙 영역에 생성되는데 힙 영역은 모든 스레드가 접근 가능하며 공유 가능한 메모리 영역입니다. 또한 GC에 의해 사용되지 않는 객체는 제거됩니다.
</details>

<br>

#### **자바에서 힙 영역은 어떻게 구성되어 있으며 어떻게 동작하나요?**

<details>
<summary>나의 답변</summary>

>힙 영역은 Eden, S0, S1, Old Generation 영역으로 구분되어 있습니다. Eden 영역은 어떠한 객체가 맨 처음 생성되면 Eden 영역에 위치하게 됩니다. 이때 Minor GC가 발생하면 미사용 객체 제거와 함께 아직 살아남은 객체는 S0 또는 S1 영역으로 이동하게 됩니다. 여기서 Survivor 영역을 거치지 않고 바로 Old Generation 영역으로 넘어가는 경우도 있는데 이때는 객체의 크기가 Survivor 영역보다 큰 경우 입니다.
S0, S1 영역으로 넘어온 객체는 둘 중 한곳으로 넘어오게 됩니다. 또한 무조건 둘 중 한곳은 비워있게 되고 객체가 31 score를 넘어가게 되면 Old Generation 영역으로 넘어가게 됩니다.
Old Generation 영역에서 살아남아있던 객체들이 일정 수준 쌓이게되면 Full GC가 발생하고 이때 STW(Stop The World)가 발생하게 됩니다. STW가 길어지면 문제가 있으므로 JVM을 개선 및 튜닝을 해야할 필요가 있다 생각합니다.
</details>

<br>

#### **프로세스의 상태중 new 상태와 ready 상태가 따로 구분되어 있는데 왜 구분되어 있나요? new 상태없이 ready 상태로 되면 안되는 이유가 따로 있을까요?**

<details>
<summary>나의 답변</summary>

> new 상태에서는 프로세스의 메모리 할당과 PCB의 정보를 생성하기 위한 상태입니다. 하지만 이러한 과정을 ready 상태에서 하게 된다면 스케줄러 디스패치가 ready 상태에 있는 프로세스들 중 적절한 프러세스를 찾아 실행시키게 되는 과정에서 프로세스의 상태를 한번 더 체크해야하고 결국 이는 오버헤드가 발생합니다.  
</details>

<br>

#### **CPU 스케줄링의 한 형태인 스와핑은 무엇인가요?**

<details>
<summary>나의 답변</summary>

> 스와핑이란 현재 실행중인 프로세스를 디스크에 저장하고 다른 프로세스를 로드하여 작업을 수행한 뒤 다시 기존 프로세스를 로드하여 실행하는 작업입니다. 스와핑은 현재 물리적인 메모리 공간이 부족한 경우 적용할 수 있는 기법입니다. 다만 기본적으로 디스크에 읽고 씀으로써 메모리에 접근하는 것보다 느리며 이과정에서 오버헤드가 발생하며 성능이 느려질 수 있습니다. 따라서 만약 우리가 물리적인 메모리가 충분하지 않은 상황에서 다른 선택지가 없는 경우에 사용해야 합니다.
</details>

<br>

#### **context switch가 필요한 이유가 무엇인가요?**

<details>
<summary>나의 답변</summary>

> context switch란 하나의 프로세스가 CPU를 독점적으로 사용하지 못하도록 방지하기 위해 필요합니다.
</details>
 
<br>

#### **context switch의 장점과 단점이 무엇인가여요?**

<details>
<summary>나의 답변</summary>

> 장점은 비싼 CPU를 여러 프로세스나 스레드를 동시에 실행할 수 있도록 합니다. 이는 생산성과 효율성을 증가시킵니다. 또한 독점적으로 CPU를 가지는 것을 방지하며 고아 상태를 방지합니다.
하지만 단점은 오버헤드가 발생할 수 있으며, 캐시 미스가 발생할 수 있습니다. 프로세스가 CPU 캐시에 저장한 데이터를 잃을 때 발생하는 캐시 미스는 있어야할 데이터가 없다면 메모리에서 다시 로드해야 하므로 성능이 느려집니다.
</details>

<br>

#### **프로세스 종료에서 좀비 프로세스는 무엇인가요?**

<details>
<summary>나의 답변</summary>

> Unix 및 Unix와 비슷한 운영체제에서 좀비 프로세스 또는 소멸된 프로세스는 exit 시스템 호출을 하여 종료되었지만 아직 여전히 프로세스 테이블에 남아있는 프로세스 입니다.
보통 프로세스는 종료되면 바로 제거되는게 아니라 아주 짧은 시간이지만 남아있게 됩니다. 그런 다음 부모 프로세스가 wait 시스템 호출을 하여 프로세스 정리를 하는데 이때 제거되지 않고 남은 프로세스를 말합니다. 이러한 좀비 프로세스가 쌓인다면 성능에 문제가 발생할 수 있습니다.
</details>

<br>

#### **프로세스 종료에서 고아 프로세스는 무엇인가요?**

<details>
<summary>나의 답변</summary>

> 부모 프로세스에 의해 만들어진 자식 프로세스가 아직 실행중이지만 부모 프로세스가 죽은 프로세스입니다. 부모가 죽어 고아가 된 프로세스는 init 프로세스가 주기적으로 wait 시스템을 호츨하여 새로운 부모 프로세스를 지정해줍니다.
</details>

<br>

#### **공유 메모리 시스템이란 무엇인가요?**

<details>
<summary>나의 답변</summary>

> 공유 메모리 시스템이란 원칙적으로 운영체제는 프로세스간 메모리 접근을 허용하지 않는데 이를 허용하는 프로세스입니다. shared memory segment라는 것을 사용하여 통신하게 됩니다.
</details>

<br>

#### **공유 메모리 시스템에서 주의할 점은 무엇이 있을까요?**

<details>
<summary>나의 답변</summary>

> race condition, 동기화, 캐시 일관성, 메모리 부족 현상이 발생할 수 있습니다.
</details>

<br>

#### **동기, 비동기는 어떻게 동작되는 건가요?**

<br>

정리 글 

<br>

https://kdg-is.tistory.com/entry/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%9E%80
