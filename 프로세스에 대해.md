### **프로세스란 무엇인가?**
<hr>

- 프로세스란 현재 메모리에서 실행중인 프로그램 및 태스크(작업)을 의미합니다.

<br>

### **프로세스는 어떻게 구성되어 있는가?**
<hr>

- 프로세스는 텍스트 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분되어 있습니다.
- 텍스트 영역은 실행 코드가 있으며, 여기에는 명령 및 상수가 포함되어 있습니다.
- 데이터 영역은 초기화되어 있지 않거나 초기화가 이루어진 전역 변수 및 전역 상수가 포함되어 있습니다.
- 힙 영역은 런타임시 생성되는 객체나 배열이 포함되어 있습니다.
- 스택 영역은 함수의 지역변수, 매개변수, 반환 주소가 포함되어 있습니다.
- 텍스트 영역, 데이터 영역은 고정된 크기를 가지고 있습니다. 그렇기 때문에 프로그램 실행시 동적으로 크기가 변하지 않습니다. 반면 힙 영역이나 스택 영역은 프로그램 실행시 동적으로 크기가 할당됩니다.

<br>

### **프로세스의 상태는 어떻게 구성되어 있는가?**
<hr>

- 프로세스의 상태는 생성 상태, 준비 상태, 실행 상태, 대기 상태, 종료 상태 총 5가지로 구분되어 있습니다.

#### **생성 상태**

- 프로세스가 생성중인 상태입니다. 이 상태에서는 프로세스에 대한 메모리 할당 및 프로세스의 PCB가 생성됩니다.

#### **준비 상태**

- 준비 상태는 프로세스 디스패치에 의해 자원이 할당되면 실행할 수 있는 상태입니다.
- 프로세스 디스패치는 준비 상태에 있는 여러 프로세스 중 적절한 프로세스를 찾아 CPU를 할당해줍니다.

#### **실행 상태**

- 실행 상태는 프로세스가 CPU를 사용하여 자신의 임루를 수행중인 상태입니다.
- 실행 상태에서 프로세스가 자신의 임무를 정상적으로 완료하면 종료 상태로 옮겨집니다.
- 실행 상태에서 비밀번호 입출력 등 I/O 작업이나 어떠한 이벤트를 기다리게 되는 경우 해당 프로세스는 대기 큐에 옮겨지며 대기 상태가 됩니다.
- 실행 상태에서 인터럽트에 의해 준비 상태로 옮겨질 수 있습니다.

#### **대기 상태**

- 실행 상태에 놓여진 프로세스가 비밀번호 입출력 등과 같은 I/O 작업이나 어떠한 이벤트로 인해 대기하게 되는 경우 대기 큐에 옮겨지며 해당 프로세스는 대기 상태가 됩니다.
이러한 대기 상태에 놓여진 프로세스는 I/O 작업이나 이벤트가 완료되면 준비 상태로 옮겨지게 됩니다.

<br>

### **프로세스 제어 블럭이 무엇인가?**
<hr>

- 프로세스 제어 블럭(PCB)는 운영체제가 프로세스를 관리하기 위해 만들어진 데이터 구조입니다.
- PCB는 프로세스가 생성되고 종료되면 소멸합니다. 운영체제는 PCB에 저장된 정보를 사용하여 프로세스 실행을 관리하고 올바르게 실행되도록 하는데 필요한 자원에 대한 접근할 수 있는지 확인합니다.


<br>

### **context switch란 무엇인가?**
<hr>

- 문맥 교환은 운영체제가 실행중인 프로세스를 저장하고 다른 프로세스를 로드하여 실행 시킨 후 다시 기존 프로세스로 돌아가 작업을 하는 것입니다.
- 일반적으로 커널 모드이건 사용자 모드이건 상관없이 PCB를 저장하는 작업을 수행하고 나중에 다시 실행할 수 있도록 복구 작업을 실행합니다.

#### **context switch가 필요한 이유가 뭘까?**

- context switch가 없다면 어떠한 프로세스가 CPU를 독점할 가능성이 있습니다. 그렇기 때문에 단일 프로세스가 CPU를 독점하는 것을 방지하기 위해 필요합니다.

#### **context switch의 장점?**

- context switch를 통해 한정적인 CPU를 최대한 사용하여 여러 프로세스나 스레드를 동시에 실행할 수 있습니다. 이렇게 효율성이나 생산성을 증가시킬 수 있습니다.
- context switch를 통해 여러 프로세스 또는 스레드가 CPU, 메모리 등과 같은 시스템 자원을 공유할 수 있습니다. 이는 자원의 낭비를 막을 수 있습니다.
- 앞서 언급한거처럼 프로세스가 독점적으로 CPU를 가지는 것을 방지할 수 있습니다.

#### **context switch의 단점?**

- 프로세스를 저장하고 복구하고 하는 작업에서 오버헤드가 발행하므로 성능이 저하됩니다.
- 프로세스를 저장하고 복구하는 작업에서 캐시 미스가 발생하여 있어야할 데이터가 없다면 운영체제는 프로세스를 다시 메모리에 데이터를 로드해야하므로 성능이 저하됩니다.

<br>

### **프로세스 연산에 대해**
<hr>

#### **프로세스 생성은 어떻게 되는가?**

- 생성하는 프로세스를 부모 프로세스라하고, 새로운 프로세스를 자식 프로세스라 합니다. 이러한 구조는 트리 구조를 가지게 됩니다.
- 일반적으로 프로세스가 자식 프로세스를 생성할 때 자식 프로세스는 수행해야할 임무에 대해 자원이 필요합니다. 이러한 자원은 운영체제로부터 할당 받거나 부모 프로세스가 가진 자원 중 부분 집합만 사용할 수 있도록 제한을 할 수 있습니다.
- 부모 프로세스는 자원을 분할하여 자신의 자식 프로세스에게 나누어 주거나 같이 사용할 수 있도록 할 수 있습니다. 또한 부모 프로세스는 자식 프로세스가 과도하게 생성되는 것을 방지할 수 있으며, 과부화 상태로 빠지는 것을 방지할 수 있습니다.


#### **프로세스 종료은 어떻게 되는가?**

- 자원을 할당받은 프로세스는 자신의 임무가 끝나면 종료됩니다.
- 부모 프로세스는 자식 프로세스를 종료하기 위해 PID를 알아야 하는데 자식 프로세스가 만들어지면 자식 프로세스의 PID는 부모 프로세스에게 전달됩니다.
- 부모 프로세스가 종료되면 자식 프로세스 또한 종료됩니다. 이를 연쇄적 종료라 합니다.

#### **좀비 프로세스란 무엇인가?**

- Unix 및 Unix와 비슷한 운영체제에서 좀비 프로세는 또는 소멸된 프로세스는 exit 시스템 호출로 인해 종료되었지만 여전히 프로세스 테이블에 남아있는 프로세스 입니다. 
- 보통 프로세스가 종료되면 바로 제거되는게 아니라 아주 짧은 시간이지만 남아 있게 됩니다. 그런 다음 부모 프로세느는 wait 시스템을 호출하여 좀비 프로세스 식별자와 프로세스 테이블을 읽은 다음 프로세스를 정리하고 프로세스 디스크립터를 해제하게 되는데 이 과정에도 불구하고 남은 프로세스 입니다.

#### **고아 프로세스란 무엇인가?**

- 고아 프로세스란 자식 프로세스는 자신의 임무를 수행하기 위해 실행중인 상태이지만 부모 프로세스가 종료된 프로세스입니다. 부모가 죽어 고아가된 프로세스는 init 프로세스가 주기적으로 wait 시스템을 호출하여 새로운 부모 프로세스를 지정해줍니다.



