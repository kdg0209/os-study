### **CPU 스케줄링의 기본개념은?**
<hr>

- 다중 프로그래밍의 목적은 CPU를 최대한 사용하는 것입니다. 그렇게 하기위해서는 항상 실행중인 프로세스가 있어야 합니다. 만약 어떤 프로세스가 I/O 작업으로 인해
대기하게 되는 경우 운영체제는 해당 CPU를 다른 프로세스에게 할당하여 항상 실행하도록 하는것입니다. 

#### **CPU 버스트와 I/O 버스트란 무엇인가?**

- 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성되어 있습니다. 
- 프로세스 실행은 CPU 버스트로 시작합니다. 뒤이어 I/O 버스트가 따라오며, 다시 그 뒤에 CPU 버스트가 따라옵니다. 만약 마지막 CPU 버스트는 그 뒤에 또다른 I/O 버스트가 오는게 아닌 프로세스 종료를 위한 시스템 콜이 오게됩니다.
- 조금더 쉽게 표현하면 CPU를 사용하다가 I/O 작업으로 인해 대기하다가, 다시 CPU를 사용하고, 다시 I/O 작업으로 인해 대기하고 이러한 과정입니다. 
- CPU를 사용할 때를 CPU 버스트라하고, I/O 작업을 기다릴 때는 I/O 버스트라 합니다.

![스크린샷 2023-03-15 오후 8 18 25](https://user-images.githubusercontent.com/80187200/225293896-d618ec8f-a7f0-47bd-812f-1909298d93f4.png)

#### **CPU 스케줄러란?**

- CPU가 유휴 상태가 될 때마다, 운영체제는 준비 큐에 있는 여러 프로세스들 중 적절한 프로세스를 찾아 CPU를 할당하게 됩니다. 이때 어떻게 프로세스를 선택하는지는 CPU 스케줄러가 합니다.
- CPU 스케줄러는 자신만의 알고리즘을 사용하여 준비 큐에 있는 여러 프로세스들 중 하나를 선택하게 됩니다.
- 준비 큐에 있는 모든 프로세스는 CPU를 할당받아 실행되길 기다리고 있으며, 준비 큐에 있는 레코드들은 일반적으로 PCB(프로세스 제어 블록)입니다. 


#### **선점과 비선점 스케줄링이란?**

##### **비선점 스케줄링**

- 비선점 스케줄링이란 CPU가 한 프로세스에게 할당되면 해당 프로세스가 종료하든지, 대기상태로 전황되어야지만 CPU를 방출하게 됩니다. 그 전까지는 점유하게 됩니다.

##### **선점 스케줄링**

- 한 프로세스가 CPU를 할당받아서 실행되고 있을 때, 다른 프로세스가 CPU를 차지하여 기존 프로세스를 중지한 뒤 자신이 실행되도록 하는 기법입니다.
- Windows, macOs, Linux 및 Unix를 포함하여 대부분의 최신 운영체제들은 선점 스케줄링 기법을 사용합니다.
- 선점 스케줄링을 사용할 때, 데이터가 다수의 프로세스에 의해 공유되고 있다면 race-condition이 발생할 수 있습니다. 그렇기 때문에 동기화 매커니즘이 필요로 합니다.

#### **디스패처란?**

- 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에게 주는 모듈입니다.
- 디스패처는 모든 프로세스들이 context-switch 시 호출되므로, 가능한 빨리 수행되어야 합니다. 
- 디스패처가 하나의 프로세스를 정지하고 다른 프로세스를 시작하기까지 걸리는 시간을 디스패처 지연시간이라 합니다.

![스크린샷 2023-03-15 오후 8 38 56](https://user-images.githubusercontent.com/80187200/225298235-503de190-9978-4dbe-bea0-d6b4caec2e2e.png)

##### **자발적 context-switch란?**

- 프로세스가 비밀번호 입력등의 I/O 작업으로 인해 대기 상태가 되었을 경우 발생합니다.
- 프로세스가 종료되었을 경우 발생합니다.
- 개인적 생각으로 비선점 스케줄링이란 비슷한 점이 있는거 같다.

##### **비자발적 context-switch란?**

- 타임 슬라이스가 만료되었거나, 우선 순위가 더 높은 프로세스에 의해 CPU를 빼앗겼을 때 발생합니다.

<br>

### **스케줄링의 기준은 뭐가 있을까?**
<hr>

#### **CPU 이용률**

- 우리는 가능한 CPU를 최대한 바쁘게 유지하길 원합니다. 개념적인 수치로는 0% ~ 100%까지 있습니다.
- Linux, macOs 시스템에서는 top 명령어를 통해 CPU 이용률을 얻을 수 있습니다.

#### **처리량**

- 단위 시간당 완료된 프로세스의 개수입니다.

#### **총 처리 시간**

- 총 처리 시간은 준비 큐에서 대기한 시간과 실행 시간, I/O 시간을 합친 시간입니다.

#### **대기 시간**

- 프로세스가 준비큐에서 보낸 시간의 총 합입니다.

#### **응답 시간**

- 하나의 요청을 보낸 후 첫번째 응답이 오기까지의 시간입니다.
- 응답시간이라 하는 이 기준은 응답이 시작되는 데까지 걸리는 시간이지, 그 응답을 출력하는데 걸리는 시간이 아닙니다.

<br>

### **스케줄링 알고리즘의 종류**
<hr>

#### **선입 선처리 스케줄링**

- 선입 선처리 스케줄링은 말 그대로 CPU를 먼저 요청한 프로세스에게 CPU를 할당하는 것입니다.
- 프로세스가 준비 큐에 진입하면 해당 프로세스의 PCB를 준비 큐의 마지막에 삽입합니다. 그리고 CPU가 가용상태가 되면 앞 부분의 프로세스에게 할당합니다. 그리고 프로세스가 실행되면 준비 큐에서 제거됩니다.

##### **장점**

- 스케줄링 이해와 구현이 단순합니다.
- 준비 큐에 있는 모든 프로세스들은 실행될거기 때문에 기아 상태가 발생하지 않습니다.

##### **단점**

- CPU 사용 기간이 긴 프로세스들에 의해 사용 시간이 짧은 프로세스들이 오래 기다려야하므로 호휘 효과가 발생될 수 있습니다.
- CPU 사용 기간이 긴 프로세스가 있다면 뒤에 있는 모든 프로세스들을 대기시켜야 하므로 평균 대기 시간이 길어지게 됩니다.
- 비선점 방식이므로 대화형 프로세스에는 부적합합니다.

#### **최단 작업 우선 스케줄링**

- 최단 작업 우선 스케줄링은 프로세스 다음에 CPU 버스트 길이를 연관시킵니다. CPU가 가용상태가 되면 가장 작은 다음 CPU 버스트를 가진 프로세스에게 CPU를 할당합니다.
- CPU 버스트의 길이가 같다면 우선 순위를 정하기 위해 선입 선처리 스케줄링이 적용됩니다.

##### **장점**

- 항상 실행 시간이 짧은 작업을 신속하게 실행하므로 평균 대기 시간이 짧습니다.

##### **단점**

- 긴 작업들은 짧은 작업들이 종료되어야 CPU를 할당받을 수 있으므로 기아 상태가 발생하게 됩니다.
- 기본적으로 짧은 CPU 버스트를 가진 프로세스들이 우선적으로 실행되므로 불공정합니다.
- 실행 시간을 예측하기 어려워 실용적이지 못합니다.

#### **라운드 로빈 스케줄링**

- 라운드 로빈 스케줄링이란 시분할 시스템을 위해 설계된 선점형 스케줄링 기법입니다.
- 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU를 할당받게 됩니다.
- CPU 자원을 사용할 수 있는 기회를 프로세스들에게 공평하게 제공하기 위한 방법으로 각 프로세스에게 일정 시간을 할당하고, 만약 프로세스의 CPU 버스트가 시간 할당량보다 작은 경우는 CPU를 자발적으로 방충합니다.
만약 CPU 버스트가 시간 할당량보다 큰 경우 해당 프로세스는 context-switch에 의해 다시 준비큐의 마지막에 삽입됩니다. 그리고 CPU 스케줄러는 다음 준비큐에 있는 프로세스에게 CPU를 할당합니다.
- 라운드 로빈 스케줄링은 유일하게 실행 가능한 프로세스가 아니라면 연속적으로 두 번이상의 시간 할당량을 받는 프로세스는 없습니다.

##### **장점**

- CPU를 독점적으로 사용하는 프로세스가 없으므로 공평합니다.
- 대화식 프로세스에 적합합니다.

##### **단점**

- 시간 할당량이 너무 작으면 context-switch가 너무 빈번히 발생하여 오버헤드가 큽니다.
- 시간 할당량이 너무 크면 선입 선처리 스케줄링과 같아 집니다.

#### **우선 순위 스케줄링**

- 우선순위가 각 프로세스들에 연관되어 있습니다. CPU는 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당합니다. 만약 우선순위가 같다면 선입 선처리 스케줄링이 적용됩니다.
- 시스템마다 0이 우선순위가 높은건지, 100이 우선순위가 높은건지 각 시스템마다 다릅니다.

##### **장점**

- 프로세스마다 상대적 중요성을 정의할 수 있습니다.

##### **단점**

- 무한 봉쇄 및 기아 상태가 발생할 수 있습니다. 만약 계속하여 우선순위가 높은 프로세스들이 진입한다면 그보다 낮은 프로세스들은 영원히 기다리게 됩니다.
- 무한 봉쇄의 문제를 해결하기 위한 방법으로 노화가 있습니다. 노화란 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점차적으로 증가시키는 것입니다.

##### **우선순위 결정방법**

- 우선순위는 내부적 또는 외부적으로 결정될 수 있습니다.
- 내부적 우선순위는 제한시간, 메모리 요구, 열린 파일의 수, 평균 I/O 버스트의 평균 CPU 버스트의 비율 등이 계산에 사용됩니다.
- 외부적 우선순위는 프로세스의 중요성, 컴퓨터 사용을 위해 지불하는 비용, 작업을 지원하는 부서, 정치적인 요인에 의해 결정됩니다.

##### **선점 우선순위와 비선점 우선순위**

- 우선순위 스케줄링은 선점, 비선점이 될 수 있습니다.
- 선점형 우선순위는 프로세스가 준비큐에 도착하면 새로 도착한 프로세스의 우선순위를 현재 프로세스의 우선순위와 비교하여 새로 도착한 프로세스의 우선순위가 더 높다면 CPU를 선점하게 됩니다.
- 비선점형 우선순위는 단순히 준비큐의 마지막에 새로운 프로세스를 삽입하게 됩니다.

#### **다단계 큐 스케줄링**

- 우선순위마다 준비큐를 형성해 놓은 방식입니다.
- 각 큐는 별도의 스케줄링 알고리즘을 가지고 있으며, 큐 사이에도 스케줄링이 존재합니다.
- 각 큐는 절대적인 우선순위를 가지며, 우선순위가 높은 큐에 있는 프로세스들부터 실행되며, 우선순위가 높은 큐들이 모두 비어있어야지만 다음 우선순위 큐로 넘어가게 됩니다.
- 프로세스들이 시스템 진입 시 영구적으로 하나의 큐에 삽입됩니다. 그리고 해당 프로세스들은 다른 큐로 이동할 수 없습니다. 그렇기 때문에 프로세스들은 큐들 사이를 이동할 수 없기 때문에 오버헤드가 적고 유연성이 떨어지게 됩니다.
- 우선순위가 낮은 프로세스가 오랫동안 CPU 할당을 가다리는 기아 현상이 발생될 수 있습니다.

![스크린샷 2023-03-15 오후 9 31 56](https://user-images.githubusercontent.com/80187200/225309672-0efb45e3-2c36-473c-87e0-970ac14761e8.png)

#### **다단계 큐 피드백 스케줄링**

- 다단계 큐 스케줄링과 마찬가지로 여러개의 준비 큐를 형성해 놓습니다.
- 프로세스 생성시 가장 높은 우선순위 큐에 삽입되게 됩니다. 해당 프로세스는 선입 선출 순서로 CPU를 할당받아 실행됩니다. 그리고 해당 큐의 시간 할당량이 끝나면 한 단계 아래 큐로 삽입되게 됩니다.
- 단계가 내려갈수록 시간 할당량이 증가하게 됩니다.
- 프로세스는 큐 사이를 이동할 수 있습니다. 어떤 프로세스가 CPU 시간을 많이 소비하면 낮은 우선순위 큐로 이동하게 되며, I/O 중심의 프로세스는 높은 우선순위 큐로 이동하게 됩니다.
- 가장 아래의 큐에 담긴 프로세스들은 기아 상태를 방지하기 위해 점차 높은 우선순위로 이동할 수 있습니다.

![스크린샷 2023-03-15 오후 9 35 15](https://user-images.githubusercontent.com/80187200/225310374-5324701d-5e5a-43f0-9d96-0a70f333ad7a.png)

<br>

### **스레드 스케줄링**
<hr>

- 대부분의 최신 운영체제에서는 스케줄되는 대상은 프로세스가 아닌 커널 수준 스레드입니다. 사용자 수준 스레드는 사용자 모드의 스레드 라이브러리에 의해 생성 및 관리되고 커널은 사용자 수준 스레드의 존재를 모릅니다.
- 사용자 수준 스레드가 CPU상에서 실행되기 위해 LWP를 통해 간접적인 방식이라도 커널 수준 스레드에 매칭되어야 합니다.


#### **프로세스 경쟁 범위(Process Contention Scope)**

- 다대일, 다대다 모델을 구현하는 시스템에서의 스레드 라이브러리는 사용자 수준 스레드를 이용 가능한 LWP에 스케줄링합니다.
- 프로세스 경쟁 범위는 동일한 프로세스내에 있는 여러 스레들이 CPU를 경쟁하기 때문에 프로세스 경쟁 범위라 합니다.

#### **시스템 경쟁 범위(System Contention Scope)**

- 스레드 라이브러리가 사용자 수준 스레드를 이용 가능한 LWP에 스케줄링 된다고할 때, 스레드가 실제로 CPU 상태에서 실행중이라는 것을 의미하지 않습니다. 이때 실제로 CPU 상에서 실행되기 위해서는 운영체제가 LWP의 커널 스레드를 물리적인 CPU 코어로 스케줄하는 것이 필요합니다.
- CPU상에서 어느 커널 스레드를 스케줄 할 것인지 정하기 위해 커널은 시스템 경쟁 범위를 사용합니다.
- 시스템 경쟁 범위는 시스템상의 모든 스레드 사이에서 일어납니다. Windows, Linux와 같은 일대일 모델을 사용하는 시스템은 오직 SCS만을 사용하여 스케줄합니다.

<br>

### **다중 처리기 스케줄링**
<hr>

- 다중 처리기 스케줄링이란 여러 CPU가 있는 다중 처리기 시스템입니다.
- 다중 처리기 스케줄링에는 비대칭 다중 처리와 대칭 다중 처리가 있습니다.


#### **비대칭 다중 처리**

- 비대칭 다중 처리는 마스터 서버의 역할을 하는 하나의 처리기가 모든 스케줄링과 관련된 일정, 입출력 처리, 여타 활동을 취급하고, 다른 처리기는 사용자 코드만 수행합니다.
- 마스터 서버의 역할을 수행하는 하나의 처리기가 시스템 자료구조에 접근하므로 다른 처리기간의 커널 내 자료를 공유할 필요가 없습니다.
- 단점은 마스터 서버가 전체 시스템 성능을 저하할 수 있는 병목이 발생할 수 있습니다.


#### **대칭 다중 처리**

- 대칭 다중 처리는 각 프로세스에서는 스스로 스케줄링할 수 있습니다.
- 각각의 프로세서의 스케줄러가 준비큐를 검사하고, 실행할 스레드를 선택하여 스케줄링합니다.
- 모든 프로세스가 공통의 준비큐도 있지만, 각 처리기마다 프라이빗 큐도 있습니다.
- 공통 큐에서는 race-condition이 발생할 수 있으므로 두개의 프로세스가 동일한 스레드를 스케줄링 못하도록 하고, 큐에서 스레드가 제거되지 않도록 보장해야 합니다.
- 공통 큐에서는 race-condition 같은 문제가 발생할 수 있지만 프라이빗 큐에서는 해당 문제가 발생하지 않습니다.

![스크린샷 2023-03-16 오후 10 26 36](https://user-images.githubusercontent.com/80187200/225631304-92944675-042f-45e4-b4fa-5704f7beb407.png)

<br>

### **다중 코어 프로세서**
<hr>

- 다중코어란 하나의 프로세서 칩에 여러개의 코어를 장착한것입니다. 각 코어는 구조적인 상태를 유지하고 있어 운영체제 입장에서는 개별적인 논리적 CPU처럼 보이게 됩니다.
- CPU 각각이 프로세서 칩을 하나씩 가지고 있는 시스템보다 속도도 빠르고 적은 전력을 소모합니다.

#### **메모리 멈춤이란**

- 캐시 미스 등의 원인으로 인해 프로세스가 메모리에 접근할 때 데이터가 가용해지길 기다리면서 발생하는 대기 시간입니다.

#### **하드웨어 스레드란**

- 메모리 멈춤의 문제를 해결하기 위해 하나의 코어에 2개 이상의 스레드를 할당하는 것입니다.
- 한 스레드가 메모리 멈춤현상에 의해 멈추면 코어는 다른 스레드로 전환이 가능합니다. 그렇기 때문에 메모리 멈춤 현상이 발생하면 코어는 작업 스레드를 다른 스레드로 전환하여 작업을 진행합니다. 

#### **거친 다중 스레딩이란**

- 거친 다중 스레딩이란 스레드가 메모리 멈춤과 같은 긴 지연시간을 발생시킬 때까지 한 처리기에서 수행됩니다. 그러다가 메모리 멈춤 현상이 발생하면 다른 스레드로 전환됩니다. 이때 다른 스레드로 전환될 때 기존 스레드의 명령어 파이프라인이 완전히 정리되어야 하므로 스레드란 교환 비용이 많이 듭니다.

#### **세밀한 다중 스레딩이란**

- 세밀한 다중 스레딩은 보통 명렁어 주기의 경계에서 스레드 교환이 일어납니다. 스레드 교환을 위한 회로적 자원이 필요하지만 교환 비용은 감소하게 됩니다.

#### **부하 균등화란**

- 부하 균등화란 각 처리기 사이에 부하를 균등하게 배분하도록 하는 것입니다. pull migration과 push migration이 있습니다.
- 부하 균등화는 각 처리기가 자신만의 준비 큐를 가지고 있는 시스템에서만 필요한 기능입니다. 공통 준비 큐가 있는 시스템에서는 하나의 처리기가 쉬게되면 곧바로 준비 큐에서 새로운 프로세스를 선택하여 실행하기 때문에 부하 균등화가 필요 없습니다.

##### **push migration**

- 특정 태스크가 주기적으로 각 처리기의 부하를 검사하고, 만일 불균형 상태가 있는 처리기가 있으면 과부하인 처리기에서 상대적으로 덜 바쁜 처리기로 스레드를 이동시킴으로써 부하를 배분합니다.

##### **pull migration**

- 쉬고 있는 처리리가 바쁜 처리기의 처리를 기다리고 있는 프로세스를 가져옵니다. 

#### **처리기 선호도란**

- 예를들어 부하 균등화로 인해 스레드가 다른 처리기로 이주한다면 어떤일이 발생할까? 그에 대한 답은 기존에 머물러 있던 처리기의 캐시 내용은 필요가 없어지므로 무효화해야 합니다. 그리고 이주가고자 하는 처리기에 다시 캐시를 채워야 합니다. 캐시 무효화 및 다시 채우는 비용은 많이 들기 때문에 대부분의 운영체제에서는 스레드를 다른 처리기로 이주시키지 않고 같은 처리기에서 계속 실행시키면서 WARM CACHE를 이용하려고 합니다.
- 공통 준비 큐를 사용하면 스레드는 어느 처리기에서건 실행될 수 있습니다. 따라서 스레드가 새 프로세스에 스케줄링되면 해당 프로세스의 캐시를 무효화 및 다시 채우는 비용이 듭니다. 하지만 프라이빗 큐를 사용하게 된다면 스레드는 항상 동일한 프로세스에서 스케줄링되므로 warm cache를 사용할 수 있습니다.

<br>

### **실시간 CPU 스케줄링**
<hr>

- 프로세스의 deadLine(마감시간)을 고려하여 스케줄링 하는 알고리즘 입니다. 여기에는 경성 실시간 시스템과 연성 실시간 시스템이 있습니다.


#### **연성 실시간 시스템이란**

- deadLine을 만족하는 것을 보장하지 않습니다.
- 중요한 프로세스가 그렇지 않은 프로세스에 비해 우선권만 가지고 있습니다.


#### **경셩 실시간 시스템이란**

- deadLine을 100% 만족하는 것을 보장합니다.
- deadLine을 못 맞추는 것은 치명적이여서 못 맞출바에는 차라리 스케줄링을 안하는게 더 나은 시스템입니다.

#### **지연시간 최소화**

- 실시간 시스템의 이벤트 중심의 특성을 보면 시스템은 일반적으로 실시간으로 발생하는 이벤트를 기다립니다. 이벤트가 발생하면 시스템은 가능한 빨리 응답하고 그에 맞는 동작을 수행해야 합니다.

##### **지연시간이란**

- 지연시간이란 이벤트가 발생하여 그에 맞는 서비스가 실행되기까지의 시간을 말합니다. 여기에는 인터럽트 지연시간과 디스패치 지연시간이 있습니다.

![스크린샷 2023-03-16 오후 11 28 02](https://user-images.githubusercontent.com/80187200/225648759-a6c25af9-6ce8-4a69-bb0a-fb9e3d82f866.png)







