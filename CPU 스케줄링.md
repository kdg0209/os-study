### **CPU 스케줄링의 기본개념은?**
<hr>

- 다중 프로그래밍의 목적은 CPU를 최대한 사용하는 것입니다. 그렇게 하기위해서는 항상 실행중인 프로세스가 있어야 합니다. 만약 어떤 프로세스가 I/O 작업으로 인해
대기하게 되는 경우 운영체제는 해당 CPU를 다른 프로세스에게 할당하여 항상 실행하도록 하는것입니다. 

#### **CPU 버스트와 I/O 버스트란 무엇인가?**

- 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성되어 있습니다. 
- 프로세스 실행은 CPU 버스트로 시작합니다. 뒤이어 I/O 버스트가 따라오며, 다시 그 뒤에 CPU 버스트가 따라옵니다. 만약 마지막 CPU 버스트는 그 뒤에 또다른 I/O 버스트가 오는게 아닌 프로세스 종료를 위한 시스템 콜이 오게됩니다.
- 조금더 쉽게 표현하면 CPU를 사용하다가 I/O 작업으로 인해 대기하다가, 다시 CPU를 사용하고, 다시 I/O 작업으로 인해 대기하고 이러한 과정입니다. 
- CPU를 사용할 때를 CPU 버스트라하고, I/O 작업을 기다릴 때는 I/O 버스트라 합니다.

![스크린샷 2023-03-15 오후 8 18 25](https://user-images.githubusercontent.com/80187200/225293896-d618ec8f-a7f0-47bd-812f-1909298d93f4.png)

#### **CPU 스케줄러란?**

- CPU가 유휴 상태가 될 때마다, 운영체제는 준비 큐에 있는 여러 프로세스들 중 적절한 프로세스를 찾아 CPU를 할당하게 됩니다. 이때 어떻게 프로세스를 선택하는지는 CPU 스케줄러가 합니다.
- CPU 스케줄러는 자신만의 알고리즘을 사용하여 준비 큐에 있는 여러 프로세스들 중 하나를 선택하게 됩니다.
- 준비 큐에 있는 모든 프로세스는 CPU를 할당받아 실행되길 기다리고 있으며, 준비 큐에 있는 레코드들은 일반적으로 PCB(프로세스 제어 블록)입니다. 


#### **선점과 비선점 스케줄링이란?**

##### **비선점 스케줄링**

- 비선점 스케줄링이란 CPU가 한 프로세스에게 할당되면 해당 프로세스가 종료하든지, 대기상태로 전황되어야지만 CPU를 방출하게 됩니다. 그 전까지는 점유하게 됩니다.

##### **선점 스케줄링**

- 한 프로세스가 CPU를 할당받아서 실행되고 있을 때, 다른 프로세스가 CPU를 차지하여 기존 프로세스를 중지한 뒤 자신이 실행되도록 하는 기법입니다.
- Windows, macOs, Linux 및 Unix를 포함하여 대부분의 최신 운영체제들은 선점 스케줄링 기법을 사용합니다.
- 선점 스케줄링을 사용할 때, 데이터가 다수의 프로세스에 의해 공유되고 있다면 race-condition이 발생할 수 있습니다. 그렇기 때문에 동기화 매커니즘이 필요로 합니다.

#### **디스패처란?**

- 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에게 주는 모듈입니다.
- 디스패처는 모든 프로세스들이 context-switch 시 호출되므로, 가능한 빨리 수행되어야 합니다. 
- 디스패처가 하나의 프로세스를 정지하고 다른 프로세스를 시작하기까지 걸리는 시간을 디스패처 지연시간이라 합니다.

![스크린샷 2023-03-15 오후 8 38 56](https://user-images.githubusercontent.com/80187200/225298235-503de190-9978-4dbe-bea0-d6b4caec2e2e.png)

##### **자발적 context-switch란?**

- 프로세스가 비밀번호 입력등의 I/O 작업으로 인해 대기 상태가 되었을 경우 발생합니다.
- 프로세스가 종료되었을 경우 발생합니다.
- 개인적 생각으로 비선점 스케줄링이란 비슷한 점이 있는거 같다.

##### **비자발적 context-switch란?**

- 타임 슬라이스가 만료되었거나, 우선 순위가 더 높은 프로세스에 의해 CPU를 빼앗겼을 때 발생합니다.

<br>

### **스케줄링의 기준은 뭐가 있을까?**
<hr>

#### **CPU 이용률**

- 우리는 가능한 CPU를 최대한 바쁘게 유지하길 원합니다. 개념적인 수치로는 0% ~ 100%까지 있습니다.
- Linux, macOs 시스템에서는 top 명령어를 통해 CPU 이용률을 얻을 수 있습니다.

#### **처리량**

- 단위 시간당 완료된 프로세스의 개수입니다.

#### **총 처리 시간**

- 총 처리 시간은 준비 큐에서 대기한 시간과 실행 시간, I/O 시간을 합친 시간입니다.

#### **대기 시간**

- 프로세스가 준비큐에서 보낸 시간의 총 합입니다.

#### **응답 시간**

- 하나의 요청을 보낸 후 첫번째 응답이 오기까지의 시간입니다.
- 응답시간이라 하는 이 기준은 응답이 시작되는 데까지 걸리는 시간이지, 그 응답을 출력하는데 걸리는 시간이 아닙니다.

<br>

### **스케줄링 알고리즘의 종류**
<hr>

#### **선입 선처리 스케줄링**

- 선입 선처리 스케줄링은 말 그대로 CPU를 먼저 요청한 프로세스에게 CPU를 할당하는 것입니다.
- 프로세스가 준비 큐에 진입하면 해당 프로세스의 PCB를 준비 큐의 마지막에 삽입합니다. 그리고 CPU가 가용상태가 되면 앞 부분의 프로세스에게 할당합니다. 그리고 프로세스가 실행되면 준비 큐에서 제거됩니다.

##### **장점**

- 스케줄링 이해와 구현이 단순합니다.
- 준비 큐에 있는 모든 프로세스들은 실행될거기 때문에 기아 상태가 발생하지 않습니다.

##### **단점**

- CPU 사용 기간이 긴 프로세스들에 의해 사용 시간이 짧은 프로세스들이 오래 기다려야하므로 호휘 효과가 발생될 수 있습니다.
- CPU 사용 기간이 긴 프로세스가 있다면 뒤에 있는 모든 프로세스들을 대기시켜야 하므로 평균 대기 시간이 길어지게 됩니다.
- 비선점 방식이므로 대화형 프로세스에는 부적합합니다.

#### **최단 작업 우선 스케줄링**

- 최단 작업 우선 스케줄링은 프로세스 다음에 CPU 버스트 길이를 연관시킵니다. CPU가 가용상태가 되면 가장 작은 다음 CPU 버스트를 가진 프로세스에게 CPU를 할당합니다.
- CPU 버스트의 길이가 같다면 우선 순위를 정하기 위해 선입 선처리 스케줄링이 적용됩니다.

##### **장점**

- 항상 실행 시간이 짧은 작업을 신속하게 실행하므로 평균 대기 시간이 짧습니다.

##### **단점**

- 긴 작업들은 짧은 작업들이 종료되어야 CPU를 할당받을 수 있으므로 기아 상태가 발생하게 됩니다.
- 기본적으로 짧은 CPU 버스트를 가진 프로세스들이 우선적으로 실행되므로 불공정합니다.
- 실행 시간을 예측하기 어려워 실용적이지 못합니다.

#### **라운드 로빈 스케줄링**

- 라운드 로빈 스케줄링이란 시분할 시스템을 위해 설계된 선점형 스케줄링 기법입니다.
- 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU를 할당받게 됩니다.
- CPU 자원을 사용할 수 있는 기회를 프로세스들에게 공평하게 제공하기 위한 방법으로 각 프로세스에게 일정 시간을 할당하고, 만약 프로세스의 CPU 버스트가 시간 할당량보다 작은 경우는 CPU를 자발적으로 방충합니다.
만약 CPU 버스트가 시간 할당량보다 큰 경우 해당 프로세스는 context-switch에 의해 다시 준비큐의 마지막에 삽입됩니다. 그리고 CPU 스케줄러는 다음 준비큐에 있는 프로세스에게 CPU를 할당합니다.
- 라운드 로빈 스케줄링은 유일하게 실행 가능한 프로세스가 아니라면 연속적으로 두 번이상의 시간 할당량을 받는 프로세스는 없습니다.

##### **장점**

- CPU를 독점적으로 사용하는 프로세스가 없으므로 공평합니다.
- 대화식 프로세스에 적합합니다.

##### **단점**

- 시간 할당량이 너무 작으면 context-switch가 너무 빈번히 발생하여 오버헤드가 큽니다.
- 시간 할당량이 너무 크면 선입 선처리 스케줄링과 같아 집니다.

#### **우선 순위 스케줄링**

- 우선순위가 각 프로세스들에 연관되어 있습니다. CPU는 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당합니다. 만약 우선순위가 같다면 선입 선처리 스케줄링이 적용됩니다.
- 시스템마다 0이 우선순위가 높은건지, 100이 우선순위가 높은건지 각 시스템마다 다릅니다.

##### **장점**

- 프로세스마다 상대적 중요성을 정의할 수 있습니다.

##### **단점**

- 무한 봉쇄 및 기아 상태가 발생할 수 있습니다. 만약 계속하여 우선순위가 높은 프로세스들이 진입한다면 그보다 낮은 프로세스들은 영원히 기다리게 됩니다.
- 무한 봉쇄의 문제를 해결하기 위한 방법으로 노화가 있습니다. 노화란 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점차적으로 증가시키는 것입니다.

##### **우선순위 결정방법**

- 우선순위는 내부적 또는 외부적으로 결정될 수 있습니다.
- 내부적 우선순위는 제한시간, 메모리 요구, 열린 파일의 수, 평균 I/O 버스트의 평균 CPU 버스트의 비율 등이 계산에 사용됩니다.
- 외부적 우선순위는 프로세스의 중요성, 컴퓨터 사용을 위해 지불하는 비용, 작업을 지원하는 부서, 정치적인 요인에 의해 결정됩니다.

##### **선점 우선순위와 비선점 우선순위**

- 우선순위 스케줄링은 선점, 비선점이 될 수 있습니다.
- 선점형 우선순위는 프로세스가 준비큐에 도착하면 새로 도착한 프로세스의 우선순위를 현재 프로세스의 우선순위와 비교하여 새로 도착한 프로세스의 우선순위가 더 높다면 CPU를 선점하게 됩니다.
- 비선점형 우선순위는 단순히 준비큐의 마지막에 새로운 프로세스를 삽입하게 됩니다.

#### **다단계 큐 스케줄링**

- 우선순위마다 준비큐를 형성해 놓은 방식입니다.
- 각 큐는 별도의 스케줄링 알고리즘을 가지고 있으며, 큐 사이에도 스케줄링이 존재합니다.
- 각 큐는 절대적인 우선순위를 가지며, 우선순위가 높은 큐에 있는 프로세스들부터 실행되며, 우선순위가 높은 큐들이 모두 비어있어야지만 다음 우선순위 큐로 넘어가게 됩니다.
- 프로세스들이 시스템 진입 시 영구적으로 하나의 큐에 삽입됩니다. 그리고 해당 프로세스들은 다른 큐로 이동할 수 없습니다. 그렇기 때문에 프로세스들은 큐들 사이를 이동할 수 없기 때문에 오버헤드가 적고 유연성이 떨어지게 됩니다.
- 우선순위가 낮은 프로세스가 오랫동안 CPU 할당을 가다리는 기아 현상이 발생될 수 있습니다.

![스크린샷 2023-03-15 오후 9 31 56](https://user-images.githubusercontent.com/80187200/225309672-0efb45e3-2c36-473c-87e0-970ac14761e8.png)

#### **다단계 큐 피드백 스케줄링**

- 다단계 큐 스케줄링과 마찬가지로 여러개의 준비 큐를 형성해 놓습니다.
- 프로세스 생성시 가장 높은 우선순위 큐에 삽입되게 됩니다. 해당 프로세스는 선입 선출 순서로 CPU를 할당받아 실행됩니다. 그리고 해당 큐의 시간 할당량이 끝나면 한 단계 아래 큐로 삽입되게 됩니다.
- 단계가 내려갈수록 시간 할당량이 증가하게 됩니다.
- 프로세스는 큐 사이를 이동할 수 있습니다. 어떤 프로세스가 CPU 시간을 많이 소비하면 낮은 우선순위 큐로 이동하게 되며, I/O 중심의 프로세스는 높은 우선순위 큐로 이동하게 됩니다.
- 가장 아래의 큐에 담긴 프로세스들은 기아 상태를 방지하기 위해 점차 높은 우선순위로 이동할 수 있습니다.

![스크린샷 2023-03-15 오후 9 35 15](https://user-images.githubusercontent.com/80187200/225310374-5324701d-5e5a-43f0-9d96-0a70f333ad7a.png)













